<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.40078125">
	<global_window_position top="23" left="0" height="919" width="1280"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ahab.20060403131358" a="E"><vh>Openomy</vh>
<v t="ahab.20060403131721"><vh>My Feeds</vh>
<v t="ahab.20060517095207"><vh>@auto-rss http://rss.openomy.com/rss/crawfles/openomy_py</vh>
<v t="ahab.20060517095320"><vh>openomy_update.py</vh></v>
<v t="ahab.20060517095320.1"><vh>openomy_sync.py</vh></v>
<v t="ahab.20060517095320.2"><vh>openomy_fs.py</vh></v>
<v t="ahab.20060517095320.3"><vh>openomy_download.py</vh></v>
<v t="ahab.20060517095320.4"><vh>openomy.py</vh></v>
<v t="ahab.20060517095320.5"><vh>openomy-python.leo</vh></v>
<v t="ahab.20060517095320.6"><vh>license.txt</vh></v>
</v>
</v>
<v t="ahab.20060403130903" a="E"><vh>Library</vh>
<v t="ahab.20060403130903.1" a="E"><vh>Documentation</vh>
<v t="ahab.20060521001517"><vh>@wiki Main_Page</vh>
<v t="ahab.20060520234228"><vh>@wiki How_Web_Apps_Work</vh></v>
<v t="ahab.20060521001251"><vh>@wiki How_Non-Web_Apps_Work</vh></v>
<v t="ahab.20060520234228.1"><vh>@wiki Currently_Supported_Methods</vh>
<v t="ahab.20060521001106"><vh>@wiki Files.GetFile</vh></v>
<v t="ahab.20060521001106.1"><vh>@wiki Files.AddFile</vh></v>
<v t="ahab.20060521001106.2"><vh>@wiki Files.DeleteFile</vh></v>
<v t="ahab.20060521001128"><vh>@wiki Files.ModifyFile</vh></v>
<v t="ahab.20060521001128.1"><vh>@wiki Files.GetAllFiles</vh></v>
<v t="ahab.20060520234449"><vh>@wiki Auth.AuthorizeUser</vh></v>
<v t="ahab.20060520234510"><vh>@wiki Auth.RegisterUser</vh></v>
<v t="ahab.20060520234510.1"><vh>@wiki Auth.GetUnconfirmedToken</vh></v>
<v t="ahab.20060520234532"><vh>@wiki Auth.GetConfirmedToken</vh></v>
<v t="ahab.20060521000819"><vh>@wiki Tags.GetTag</vh></v>
<v t="ahab.20060521000942"><vh>@wiki Tags.GetAllTags</vh></v>
<v t="ahab.20060521000942.1"><vh>@wiki Tags.CreateTag</vh></v>
<v t="ahab.20060521001003"><vh>@wiki Tags.DeleteTag</vh></v>
<v t="ahab.20060521001003.1"><vh>@wiki Tags.AddFileToTag</vh></v>
<v t="ahab.20060521001003.2"><vh>@wiki Tags.DeleteFileFromTag</vh></v>
</v>
<v t="ahab.20060521001312"><vh>@wiki Error_Codes</vh></v>
<v t="ahab.20060521001353"><vh>@wiki Glossary</vh>
<v t="ahab.20060521001414"><vh>@wiki Unconfirmed_Token</vh></v>
<v t="ahab.20060521001353.1"><vh>@wiki Confirmed_Token</vh></v>
<v t="ahab.20060521001435"><vh>@wiki Application_Key</vh></v>
<v t="ahab.20060521001414.1"><vh>@wiki Private_Key</vh></v>
</v>
</v>
<v t="ahab.20060423233314"><vh>@wiki Openomy-python</vh>
<v t="ahab.20060424002321"><vh>Overview</vh></v>
<v t="ahab.20060424002321.2"><vh>Requirements</vh></v>
<v t="ahab.20060424003925"><vh>Using the Library</vh></v>
<v t="ahab.20060424002321.3"><vh>License</vh></v>
<v t="ahab.20060424003925.1"><vh>Download</vh></v>
</v>
<v t="ahab.20060405103414.1"><vh>@wiki openomy.py</vh>
<v t="ahab.20060424002321.4"><vh>Overview</vh></v>
<v t="ahab.20060424002321.5"><vh>Structure</vh>
<v t="ahab.20060403132104"><vh>Layer 0: API, Configuration, DefaultConfiguration</vh>
<v t="ahab.20060403162622"><vh>@wiki /DefaultConfiguration</vh>
<v t="ahab.20060515111402"><vh>Members</vh></v>
<v t="ahab.20060407103634"><vh>Overriding the Defaults</vh></v>
<v t="ahab.20060424002321.6"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060424002321.7"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060403162724"><vh>@wiki /Configuration</vh>
<v t="ahab.20060515115004"><vh>Members</vh></v>
<v t="ahab.20060515114442"><vh>Methods</vh>
<v t="ahab.20060407103634.1"><vh>Instantiation</vh></v>
<v t="ahab.20060407103634.2"><vh>Getting and Setting Parameters</vh></v>
<v t="ahab.20060407103634.3"><vh>Loading and Saving</vh></v>
</v>
<v t="ahab.20060424001429"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060424001429.1"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060403162724.1"><vh>@wiki /API</vh>
<v t="ahab.20060407103204"><vh>Setting Parameters</vh></v>
<v t="ahab.20060407103204.1"><vh>Authorization</vh></v>
<v t="ahab.20060407103204.2"><vh>Dispatching the Request</vh></v>
<v t="ahab.20060407103204.3"><vh>Determining Success or Error</vh></v>
<v t="ahab.20060407103204.4"><vh>Extracting Data from the Response</vh></v>
<v t="ahab.20060423235240"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060423235240.1"><vh>Related Classes</vh></v>
</v>
</v>
<v t="ahab.20060407103327"><vh>Layer 1: Auth, Files, Tags</vh>
<v t="ahab.20060424002321.8"><vh>@wiki /Auth</vh>
<v t="ahab.20060424012520"><vh>Methods</vh></v>
<v t="ahab.20060424011950"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060424012520.1"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.9"><vh>@wiki /Files</vh>
<v t="ahab.20060424012520.2"><vh>Methods</vh></v>
<v t="ahab.20060424012520.3"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060424012520.4"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.10"><vh>@wiki /Tags</vh>
<v t="ahab.20060513132332"><vh>Methods</vh></v>
<v t="ahab.20060513132332.1"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060513132559"><vh>Related Classes</vh></v>
</v>
</v>
<v t="ahab.20060407103327.1"><vh>Layer 2: User, File, Tag, Partner (and RemoteProxy)</vh>
<v t="ahab.20060513173100"><vh>@wiki /RemoteProxy</vh>
<v t="ahab.20060514151350"><vh>Members</vh></v>
<v t="ahab.20060514151350.1"><vh>Methods</vh>
<v t="ahab.20060514205841"><vh>Instantiation</vh></v>
<v t="ahab.20060514144850"><vh>Refresh</vh></v>
<v t="ahab.20060514144850.1"><vh>Event Handlers</vh></v>
<v t="ahab.20060514154047"><vh>Attribute Magic</vh></v>
</v>
<v t="ahab.20060513173145"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060513173300"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.11"><vh>@wiki /User</vh>
<v t="ahab.20060514160357"><vh>Members</vh></v>
<v t="ahab.20060514160611"><vh>Methods</vh>
<v t="ahab.20060514160357.2"><vh>Instantiation</vh></v>
<v t="ahab.20060514161534"><vh>Configuration</vh></v>
<v t="ahab.20060514160611.1"><vh>Authorization (Login)</vh></v>
<v t="ahab.20060514160611.2"><vh>Retrieving Objects</vh></v>
<v t="ahab.20060514160755"><vh>Creating Objects</vh></v>
</v>
<v t="ahab.20060514154113"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514154523"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.12"><vh>@wiki /AutoLoginUser</vh>
<v t="ahab.20060514192458"><vh>Members</vh></v>
<v t="ahab.20060514192458.1"><vh>Methods</vh>
<v t="ahab.20060514192458.2"><vh>Instantiation</vh></v>
<v t="ahab.20060514192458.3"><vh>Login</vh></v>
</v>
<v t="ahab.20060514194447"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514194447.1"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.13"><vh>@wiki /AutoRegisterUser</vh>
<v t="ahab.20060514200659"><vh>Members</vh></v>
<v t="ahab.20060514201242"><vh>Methods</vh>
<v t="ahab.20060514201242.1"><vh>Instantiation</vh></v>
<v t="ahab.20060514201242.2"><vh>Login</vh></v>
</v>
<v t="ahab.20060514202805"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514203124"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.14"><vh>@wiki /File</vh>
<v t="ahab.20060514205410"><vh>Members</vh></v>
<v t="ahab.20060514205841.1"><vh>Methods</vh>
<v t="ahab.20060514205841.2"><vh>Instantiation</vh></v>
<v t="ahab.20060514212001"><vh>Obtaining a File object</vh></v>
<v t="ahab.20060514212001.1"><vh>Retrieving a File</vh></v>
<v t="ahab.20060514212001.2"><vh>Modifying a File</vh></v>
<v t="ahab.20060514212342"><vh>Discarding a File</vh></v>
<v t="ahab.20060514213758"><vh>Tagging and Untagging</vh></v>
</v>
<v t="ahab.20060514205414"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514205841.3"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002321.15"><vh>@wiki /Tag</vh>
<v t="ahab.20060514212909"><vh>Members</vh></v>
<v t="ahab.20060514213758.1"><vh>Methods</vh>
<v t="ahab.20060514213758.2"><vh>Instantiation</vh></v>
<v t="ahab.20060514213758.3"><vh>Obtaining a Tag object</vh></v>
<v t="ahab.20060514213758.4"><vh>Tagging and Untagging</vh></v>
<v t="ahab.20060515230058"><vh>Discarding a File</vh></v>
</v>
<v t="ahab.20060514213758.5"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514212914"><vh>Related Classes</vh></v>
</v>
<v t="ahab.20060424002340"><vh>@wiki /Partner</vh>
<v t="ahab.20060514203816"><vh>Members</vh></v>
<v t="ahab.20060514204147"><vh>Obtaining a Partner (object)</vh></v>
<v t="ahab.20060514203820"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060514203932"><vh>Related Classes</vh></v>
</v>
</v>
</v>
<v t="ahab.20060513164358"><vh>EpyDoc Reference</vh></v>
<v t="ahab.20060424002321.16"><vh>Example</vh></v>
<v t="ahab.20060424002321.1"><vh>Version History</vh></v>
</v>
<v t="ahab.20060405114844.1"><vh>@wiki openomy_update.py</vh>
<v t="ahab.20060515130317"><vh>Syntax</vh></v>
</v>
<v t="ahab.20060424003925.2"><vh>@wiki openomy_fs.py</vh>
<v t="ahab.20060515170858"><vh>Introduction</vh></v>
<v t="ahab.20060515170858.1"><vh>Pre-Requisites</vh></v>
<v t="ahab.20060515170858.2"><vh>Usage</vh></v>
<v t="ahab.20060515170858.3"><vh>Directory Structure</vh></v>
<v t="ahab.20060515170858.4"><vh>Relevant Links</vh></v>
<v t="ahab.20060515171532"><vh>Version History</vh></v>
</v>
<v t="ahab.20060405114844"><vh>@wiki openomy_sync.py</vh>
<v t="ahab.20060515123141"><vh>Syntax</vh></v>
<v t="ahab.20060515123141.1"><vh>Options</vh></v>
<v t="ahab.20060515125944.1"><vh>Examples</vh></v>
</v>
<v t="ahab.20060521014212"><vh>@wiki Openomy_Projects</vh>
<v t="ahab.20060521014254"><vh>JOpenDAV</vh></v>
<v t="ahab.20060521014254.1"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ahab.20060403130903.98" a="E"><vh>Source</vh>
<v t="ahab.20060403130903.2" a="E" tnodeList="ahab.20060403130903.2,ahab.20060403130903.3,ahab.20060519000431,ahab.20060407103347,ahab.20060403130903.4,ahab.20060403130903.5,ahab.20060403130903.6,ahab.20060403130903.7,ahab.20060403130903.8,ahab.20060403130903.9,ahab.20060403130903.10,ahab.20060403130903.11,ahab.20060403130903.12,ahab.20060403130903.13,ahab.20060403130903.14,ahab.20060403130903.15,ahab.20060403130903.16,ahab.20060407101004,ahab.20060403130903.17,ahab.20060403130903.18,ahab.20060403130903.19,adam.20070209083233,ahab.20060403130903.20,ahab.20060403130903.21,adam.20070202092013,ahab.20060403130903.22,ahab.20060403130903.23,ahab.20060403130903.24,ahab.20060403130903.25,ahab.20060403132124,ahab.20060403130903.26,ahab.20060423134114,ahab.20060423133517,ahab.20060403130903.30,ahab.20060403130903.31,ahab.20060403130903.32,ahab.20060403130903.34,ahab.20060403130903.35,ahab.20060403130903.36,ahab.20060403130903.37,ahab.20060403130903.38,ahab.20060403130903.39,ahab.20060403130903.41,ahab.20060403130903.42,ahab.20060403130903.43,ahab.20060403130903.44,ahab.20060403130903.45,ahab.20060403130903.46,ahab.20060403132124.1,ahab.20060403130903.47,ahab.20060403130903.48,ahab.20060403130903.49,ahab.20060403130903.50,ahab.20060517091304,ahab.20060403130903.51,ahab.20060403130903.52,ahab.20060403130903.53,ahab.20060403130903.54,ahab.20060403130903.55,ahab.20060403130903.56,ahab.20060403130903.57,ahab.20060403130903.58,ahab.20060403130903.59,ahab.20060403130903.60,ahab.20060403130903.61,ahab.20060403130903.62,ahab.20060403130903.63,ahab.20060403130903.64,ahab.20060403130903.65,ahab.20060403130903.66,adam.20070201144732,ahab.20060403130903.67,ahab.20060403130903.68,ahab.20060403130903.69,ahab.20060403130903.70,ahab.20060403130903.71,ahab.20060403130903.72,ahab.20060403130903.76,ahab.20060403130903.77,ahab.20060403130903.78,ahab.20060403130903.79,ahab.20060403130903.80,ahab.20060403130903.81,ahab.20060403130903.82,ahab.20060403130903.83,ahab.20060403130903.84,ahab.20060403130903.85,ahab.20060403130903.86,ahab.20060403130903.87,ahab.20060403130903.88,ahab.20060403130903.89,ahab.20060403130903.90,ahab.20060403130903.91,ahab.20060403130903.92,ahab.20060403130903.93,ahab.20060403130903.94,ahab.20060403130903.95,ahab.20060403130903.96,ahab.20060403130903.97"><vh>@nosent openomy.py</vh>
<v t="ahab.20060403130903.3"><vh>&lt;&lt; openomy declarations &gt;&gt;</vh></v>
<v t="ahab.20060519000431"><vh>Error Codes</vh></v>
<v t="ahab.20060407103347"><vh>Layer 0</vh>
<v t="ahab.20060403130903.4"><vh>class DefaultConfiguration</vh>
<v t="ahab.20060403130903.5"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.6"><vh>get</vh></v>
<v t="ahab.20060403130903.7"><vh>set</vh></v>
</v>
<v t="ahab.20060403130903.8"><vh>class Configuration</vh>
<v t="ahab.20060403130903.9"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.10"><vh>__init__</vh></v>
<v t="ahab.20060403130903.11"><vh>get</vh></v>
<v t="ahab.20060403130903.12"><vh>save</vh></v>
<v t="ahab.20060403130903.13"><vh>set</vh></v>
<v t="ahab.20060403130903.14"><vh>load</vh></v>
</v>
<v t="ahab.20060403130903.15"><vh>class API</vh>
<v t="ahab.20060403130903.16"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ahab.20060407101004"><vh>__getattr__</vh></v>
<v t="ahab.20060403130903.17"><vh>sign</vh></v>
<v t="ahab.20060403130903.18"><vh>getUrl</vh></v>
<v t="ahab.20060403130903.19"><vh>getRequest</vh></v>
<v t="adam.20070209083233"><vh>getConfigParam</vh></v>
<v t="ahab.20060403130903.20"><vh>dispatch</vh></v>
<v t="ahab.20060403130903.21"><vh>succeeded</vh></v>
<v t="adam.20070202092013"><vh>getError</vh></v>
<v t="ahab.20060403130903.22"><vh>extract</vh></v>
<v t="ahab.20060403130903.23"><vh>extractObjects</vh></v>
<v t="ahab.20060403130903.24"><vh>extractFields</vh></v>
<v t="ahab.20060403130903.25"><vh>extractId</vh></v>
</v>
</v>
<v t="ahab.20060403132124"><vh>Layer 1</vh>
<v t="ahab.20060403130903.26"><vh>class Auth</vh>
<v t="ahab.20060423134114"><vh>RegisterUser</vh></v>
<v t="ahab.20060423133517"><vh>AuthorizeUser</vh></v>
<v t="ahab.20060403130903.30"><vh>GetUnconfirmedToken</vh></v>
<v t="ahab.20060403130903.31"><vh>GetConfirmedToken</vh></v>
</v>
<v t="ahab.20060403130903.32"><vh>class Files</vh>
<v t="ahab.20060403130903.34"><vh>GetFile</vh></v>
<v t="ahab.20060403130903.35"><vh>AddFile</vh></v>
<v t="ahab.20060403130903.36"><vh>DeleteFile</vh></v>
<v t="ahab.20060403130903.37"><vh>ModifyFile</vh></v>
<v t="ahab.20060403130903.38"><vh>GetAllFiles</vh></v>
</v>
<v t="ahab.20060403130903.39"><vh>class Tags</vh>
<v t="ahab.20060403130903.41"><vh>GetAllTags</vh></v>
<v t="ahab.20060403130903.42"><vh>GetTag</vh></v>
<v t="ahab.20060403130903.43"><vh>CreateTag</vh></v>
<v t="ahab.20060403130903.44"><vh>DeleteTag</vh></v>
<v t="ahab.20060403130903.45"><vh>AddFileToTag</vh></v>
<v t="ahab.20060403130903.46"><vh>DeleteFileFromTag</vh></v>
</v>
</v>
<v t="ahab.20060403132124.1"><vh>Layer 2</vh>
<v t="ahab.20060403130903.47"><vh>class RemoteProxy</vh>
<v t="ahab.20060403130903.48"><vh>&lt;&lt; class RemoteProxy declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.49"><vh>__init__</vh></v>
<v t="ahab.20060403130903.50"><vh>__getattr__</vh></v>
<v t="ahab.20060517091304"><vh>links</vh></v>
<v t="ahab.20060403130903.51"><vh>refresh</vh></v>
<v t="ahab.20060403130903.52"><vh>_updated</vh></v>
<v t="ahab.20060403130903.53"><vh>_retrieved</vh></v>
<v t="ahab.20060403130903.54"><vh>_added</vh></v>
<v t="ahab.20060403130903.55"><vh>_renamed</vh></v>
<v t="ahab.20060403130903.56"><vh>_removed</vh></v>
</v>
<v t="ahab.20060403130903.57"><vh>class User</vh>
<v t="ahab.20060403130903.58"><vh>&lt;&lt; class User declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.59"><vh>__init__</vh></v>
<v t="ahab.20060403130903.60"><vh>obtainAccess</vh></v>
<v t="ahab.20060403130903.61"><vh>loadConfig</vh></v>
<v t="ahab.20060403130903.62"><vh>refresh</vh></v>
<v t="ahab.20060403130903.63"><vh>refreshAllTags</vh></v>
<v t="ahab.20060403130903.64"><vh>refreshAllFiles</vh></v>
<v t="ahab.20060403130903.65"><vh>checkAuthLevel</vh></v>
<v t="ahab.20060403130903.66"><vh>obtainAppCreds</vh></v>
<v t="adam.20070201144732"><vh>obtainAppAuth</vh></v>
<v t="ahab.20060403130903.67"><vh>obtainCfmToken</vh></v>
<v t="ahab.20060403130903.68"><vh>promptToAuthorize</vh></v>
<v t="ahab.20060403130903.69"><vh>addFile</vh></v>
<v t="ahab.20060403130903.70"><vh>createTag</vh></v>
<v t="ahab.20060403130903.71"><vh>getAllFiles</vh></v>
<v t="ahab.20060403130903.72"><vh>getAllTags</vh></v>
</v>
<v t="ahab.20060403130903.76"><vh>class Partner</vh>
<v t="ahab.20060403130903.77"><vh>&lt;&lt; class Partner declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.78"><vh>__init__</vh></v>
<v t="ahab.20060403130903.79"><vh>refresh</vh></v>
</v>
<v t="ahab.20060403130903.80"><vh>class Tag</vh>
<v t="ahab.20060403130903.81"><vh>&lt;&lt; class Tag declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.82"><vh>__init__</vh></v>
<v t="ahab.20060403130903.83"><vh>refresh</vh></v>
<v t="ahab.20060403130903.84"><vh>delete</vh></v>
<v t="ahab.20060403130903.85"><vh>addFile</vh></v>
<v t="ahab.20060403130903.86"><vh>deleteFile</vh></v>
</v>
<v t="ahab.20060403130903.87"><vh>class File</vh>
<v t="ahab.20060403130903.88"><vh>&lt;&lt; class File declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.89"><vh>__init__</vh></v>
<v t="ahab.20060403130903.90"><vh>refresh</vh></v>
<v t="ahab.20060403130903.91"><vh>delete</vh></v>
<v t="ahab.20060403130903.92"><vh>getUrl</vh></v>
<v t="ahab.20060403130903.93"><vh>getData</vh></v>
<v t="ahab.20060403130903.94"><vh>download</vh></v>
<v t="ahab.20060403130903.95"><vh>upload</vh></v>
<v t="ahab.20060403130903.96"><vh>addToTag</vh></v>
<v t="ahab.20060403130903.97"><vh>removeFromTag</vh></v>
</v>
</v>
</v>
<v t="ahab.20060403130903.130" tnodeList="ahab.20060403130903.130,ahab.20060403145026"><vh>@nosent openomy_update.py</vh>
<v t="ahab.20060403145026"><vh>&lt;&lt;imports&gt;&gt;</vh></v>
</v>
<v t="ahab.20060403143905" tnodeList="ahab.20060403143905,ahab.20060517091732,ahab.20060403143905.1,ahab.20060403143905.2,ahab.20060403143905.3,ahab.20060403143905.4,ahab.20060403143905.5,ahab.20060403143905.6,ahab.20060403143905.7,ahab.20060517155900,ahab.20060403143905.8,ahab.20060403143905.9,ahab.20060403143905.10,ahab.20060403143905.11,ahab.20060403143905.12,ahab.20060403143905.13,ahab.20060517092249"><vh>@nosent openomy_fs.py</vh>
<v t="ahab.20060517091732"><vh>License</vh></v>
<v t="ahab.20060403143905.1"><vh>Declarations</vh></v>
<v t="ahab.20060403143905.2"><vh>class OpenomyFS</vh>
<v t="ahab.20060403143905.3"><vh>__init__</vh></v>
<v t="ahab.20060403143905.4"><vh>getattr</vh></v>
<v t="ahab.20060403143905.5"><vh>getdir</vh></v>
<v t="ahab.20060403143905.6"><vh>rmdir</vh></v>
<v t="ahab.20060403143905.7"><vh>mkdir</vh></v>
<v t="ahab.20060517155900"><vh>mknod</vh></v>
<v t="ahab.20060403143905.8"><vh>open</vh></v>
<v t="ahab.20060403143905.9"><vh>read</vh></v>
<v t="ahab.20060403143905.10"><vh>write</vh></v>
<v t="ahab.20060403143905.11"><vh>truncate</vh></v>
<v t="ahab.20060403143905.12"><vh>release</vh></v>
<v t="ahab.20060403143905.13"><vh>unlink</vh></v>
<v t="ahab.20060517092249"><vh>link</vh></v>
</v>
</v>
<v t="ahab.20060403130903.102" tnodeList="ahab.20060403130903.102,ahab.20060403130903.103,ahab.20060403130903.104,ahab.20060403130903.105,ahab.20060403130903.106,ahab.20060403130903.107,ahab.20060403130903.108,ahab.20060403130903.109,ahab.20060403132446,ahab.20060403132406"><vh>@nosent openomy_sync.py</vh>
<v t="ahab.20060403130903.103"><vh>&lt;&lt; declarations &gt;&gt;</vh></v>
<v t="ahab.20060403130903.104"><vh>class OpenomySync</vh>
<v t="ahab.20060403130903.105"><vh>__init__</vh></v>
<v t="ahab.20060403130903.106"><vh>getRemoteFileList</vh></v>
<v t="ahab.20060403130903.107"><vh>upload</vh></v>
<v t="ahab.20060403130903.108"><vh>download</vh></v>
<v t="ahab.20060403130903.109"><vh>sync</vh></v>
</v>
<v t="ahab.20060403132446"><vh>&lt;&lt; parse command line &gt;&gt;</vh></v>
<v t="ahab.20060403132406"><vh>&lt;&lt; command execution &gt;&gt;</vh></v>
</v>
<v t="ahab.20060518153509" a="E" tnodeList="ahab.20060518153509,ahab.20060518153509.1,ahab.20060523172219,ahab.20060522201349,ahab.20060523160943,ahab.20060521175746,ahab.20060524160919,ahab.20060524160713,ahab.20060524160940,ahab.20060524160734,ahab.20060524160734.2,ahab.20060524160755,ahab.20060524160816,ahab.20060524160919.1,ahab.20060524160734.1,ahab.20060524160755.1,ahab.20060524160816.1,ahab.20060524160837,ahab.20060519001006,ahab.20060523193805,ahab.20060523171425,ahab.20060519000431,ahab.20060519001346,ahab.20060519000431.1,ahab.20060520011211,ahab.20060520011232,ahab.20060520011232.1,ahab.20060520011253,ahab.20060519001006.3,ahab.20060520015210,ahab.20060520015210.1,ahab.20060520015210.2,ahab.20060520015231,ahab.20060520015252,ahab.20060519001006.4,ahab.20060520014025,ahab.20060520014333,ahab.20060520014210,ahab.20060520014354,ahab.20060520014414,ahab.20060520014436,ahab.20060519121502,ahab.20060524230027,ahab.20060520011437,ahab.20060520011458,ahab.20060520011458.1,ahab.20060520011519,ahab.20060520011519.1,ahab.20060524154927,ahab.20060518203554.1,ahab.20060523164646,ahab.20060519001346.1,ahab.20060519001346.2,ahab.20060519004144,ahab.20060523201221,ahab.20060522200347,adam.20070203191141,adam.20070203191141.1,ahab.20060523201221,adam.20070207101731,ahab.20060523172835,adam.20070209090343,adam.20070209090343.1,ahab.20060518153509.5,ahab.20070116150015"><vh>@nosent openomy_server.py</vh>
<v t="ahab.20060518153509.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ahab.20060523172219"><vh>Storage</vh>
<v t="ahab.20060522201349"><vh>class KirbyObject</vh></v>
<v t="ahab.20060523160943"><vh>class StoredFile</vh></v>
</v>
<v t="ahab.20060521175746"><vh>Data Model</vh>
<v t="ahab.20060524160919"><vh>Identity</vh>
<v t="ahab.20060524160713"><vh>ObjectID</vh></v>
</v>
<v t="ahab.20060524160940"><vh>Objects</vh>
<v t="ahab.20060524160734"><vh>Application</vh></v>
<v t="ahab.20060524160734.2"><vh>User</vh></v>
<v t="ahab.20060524160755"><vh>Tag</vh></v>
<v t="ahab.20060524160816"><vh>File</vh></v>
</v>
<v t="ahab.20060524160919.1"><vh>Links</vh>
<v t="ahab.20060524160734.1"><vh>ApplicationUser</vh></v>
<v t="ahab.20060524160755.1"><vh>TagUser</vh></v>
<v t="ahab.20060524160816.1"><vh>FileUser</vh></v>
<v t="ahab.20060524160837"><vh>FileTag</vh></v>
</v>
</v>
<v t="ahab.20060519001006"><vh>API</vh>
<v t="ahab.20060523193805"><vh>Errors and Tokens</vh>
<v t="ahab.20060523171425"><vh>call tokens</vh></v>
<v t="ahab.20060519000431"><vh>Error Codes</vh></v>
</v>
<v t="ahab.20060519001346"><vh>REST Methods</vh>
<v t="ahab.20060519000431.1"><vh>class Auth</vh>
<v t="ahab.20060520011211"><vh>GetUnconfirmedToken</vh></v>
<v t="ahab.20060520011232"><vh>GetConfirmedToken</vh></v>
<v t="ahab.20060520011232.1"><vh>AuthorizeUser</vh></v>
<v t="ahab.20060520011253"><vh>RegisterUser</vh></v>
</v>
<v t="ahab.20060519001006.3"><vh>class Files</vh>
<v t="ahab.20060520015210"><vh>GetFile</vh></v>
<v t="ahab.20060520015210.1"><vh>AddFile</vh></v>
<v t="ahab.20060520015210.2"><vh>DeleteFile</vh></v>
<v t="ahab.20060520015231"><vh>ModifyFile</vh></v>
<v t="ahab.20060520015252"><vh>GetAllFiles</vh></v>
</v>
<v t="ahab.20060519001006.4"><vh>class Tags</vh>
<v t="ahab.20060520014025"><vh>GetTag</vh></v>
<v t="ahab.20060520014333"><vh>DeleteTag</vh></v>
<v t="ahab.20060520014210"><vh>CreateTag</vh></v>
<v t="ahab.20060520014354"><vh>AddFileToTag</vh></v>
<v t="ahab.20060520014414"><vh>DeleteFileFromTag</vh></v>
<v t="ahab.20060520014436"><vh>GetAllTags</vh></v>
</v>
<v t="ahab.20060519121502"><vh>class Debug</vh>
<v t="ahab.20060524230027"><vh>CreateApplication</vh></v>
<v t="ahab.20060520011437"><vh>ListMethods</vh></v>
<v t="ahab.20060520011458"><vh>Shutdown</vh></v>
<v t="ahab.20060520011458.1"><vh>GetRecord</vh></v>
<v t="ahab.20060520011519"><vh>GetTable</vh></v>
<v t="ahab.20060520011519.1"><vh>Reinitialize</vh></v>
</v>
</v>
</v>
<v t="ahab.20060524154927" a="E"><vh>Endpoints</vh>
<v t="ahab.20060518203554.1"><vh>class REST</vh>
<v t="ahab.20060523164646"><vh>__init__</vh></v>
<v t="ahab.20060519001346.1"><vh>__call__</vh></v>
<v t="ahab.20060519001346.2"><vh>filter</vh></v>
<v t="ahab.20060519004144"><vh>_success</vh></v>
<v t="ahab.20060523201221"><vh>_failure</vh></v>
</v>
<v t="ahab.20060522200347"><vh>class Download</vh>
<v t="adam.20070203191141"><vh>__call__</vh></v>
<v t="adam.20070203191141.1"><vh>filter</vh></v>
<v t="ahab.20060523201221"><vh>_failure</vh></v>
</v>
</v>
<v t="adam.20070207101731"><vh>WSGI</vh>
<v t="ahab.20060523172835"><vh>class Service</vh>
<v t="adam.20070209090343"><vh>__init__</vh></v>
<v t="adam.20070209090343.1"><vh>__call__</vh></v>
</v>
<v t="ahab.20060518153509.5"><vh>class Request</vh></v>
</v>
<v t="ahab.20070116150015"><vh>Startup</vh></v>
</v>
</v>
<v t="ahab.20060403131903" a="E"><vh>Tests</vh>
<v t="adam.20070207093632" a="E" tnodeList="adam.20070207093632,adam.20070207145205,adam.20070207131754,adam.20070207144556,adam.20070207144800,adam.20070207133213,adam.20070207115944,adam.20070207141345,adam.20070207123001,adam.20070207125315,adam.20070208125522,adam.20070207145327,adam.20070207131632.1,adam.20070207131632,adam.20070207145327.1,adam.20070207145832,adam.20070207145832.1"><vh>@nosent openomy_test.py</vh>
<v t="adam.20070207145205"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="adam.20070207131754"><vh>class FakeWSGIServer</vh>
<v t="adam.20070207144556"><vh>urlopen</vh></v>
<v t="adam.20070207144800"><vh>handleResponseStart</vh></v>
<v t="adam.20070207133213"><vh>parseRequest</vh></v>
<v t="adam.20070207115944"><vh>setupTestingDefaults</vh></v>
<v t="adam.20070207141345"><vh>class Response</vh></v>
</v>
<v t="adam.20070207123001"><vh>class Debug</vh>
<v t="adam.20070207125315"><vh>CreateApplication</vh></v>
<v t="adam.20070208125522"><vh>Reinitialize</vh></v>
</v>
<v t="adam.20070207145327" a="E"><vh>Tests</vh>
<v t="adam.20070207131632.1" a="TV"><vh>Test Setup</vh></v>
<v t="adam.20070207131632"><vh>Account</vh></v>
<v t="adam.20070207145327.1"><vh>Files</vh></v>
<v t="adam.20070207145832"><vh>Tags</vh></v>
<v t="adam.20070207145832.1"><vh>Files2</vh></v>
</v>
</v>
</v>
<v t="ahab.20060403130903.99" a="E"><vh>Examples</vh>
<v t="ahab.20060403130903.100" tnodeList="ahab.20060403130903.100"><vh>@nosent openomy_download.py</vh></v>
</v>
</v>
<v t="ahab.20060423233314.1"><vh>Leo Scripts</vh>
<v t="ahab.20060514170859.1"><vh>@button Save</vh></v>
<v t="ahab.20060514173814"><vh>@button ToggleSplitDir</vh></v>
<v t="ahab.20060514170859.2"><vh>@button CopyOutline</vh></v>
<v t="ahab.20060514170859" tnodeList="ahab.20060514170859,ahab.20060514171321,ahab.20060513142459,ahab.20060513134804,ahab.20060423234132,ahab.20060423235848,ahab.20060513165929,ahab.20060513173921,ahab.20060423233314.2,ahab.20060520230315,ahab.20060513164621"><vh>@file leoWiki.py</vh>
<v t="ahab.20060514171321"><vh>&lt;&lt; Wiki Scripts &gt;&gt;</vh>
<v t="ahab.20060513142459"><vh>Wiki Sync</vh></v>
<v t="ahab.20060513134804"><vh>Wiki Info</vh></v>
<v t="ahab.20060423234132"><vh>Form Data</vh></v>
</v>
<v t="ahab.20060423235848"><vh>@button Set Head</vh></v>
<v t="ahab.20060513165929"><vh>@button Tweak Section</vh></v>
<v t="ahab.20060513173921"><vh>@button Tweak Page</vh></v>
<v t="ahab.20060423233314.2"><vh>@button Publish Page</vh></v>
<v t="ahab.20060520230315"><vh>@button Retrieve Page</vh></v>
<v t="ahab.20060513164621"><vh>@button Show Me Wiki</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="adam.20070201144732">def obtainAppAuth(self):
    """ Obtain a confirmed token for the
    application using a username and password. """
    
    userName, password, email = None, None, None
    for item in (self.config, API.config):
        if not userName:
            userName = item.get('username')
        if not password:
            password = item.get('password')
        if not email:
            email = item.get('email')
            

    # Get an confirmed token first
    try:
        if email and not userName:
            cfmToken = Auth.AuthorizeUser(email, password,
                                      config=self.config)
        else:
            cfmToken = Auth.AuthorizeUser(userName, password,
                                      config=self.config)
    except OpenomyError, f:
        if f.code == ERR_BAD_USER and (username and
            password and email):
            
            cfmToken = Auth.RegisterUser(userName, password,
                              email, config=self.config)
                    
        else:
            print "Could not login as user"
            raise                              

    self.config.set('confirmedToken', cfmToken)
    self.checkAuthLevel()
    return True
</t>
<t tx="adam.20070202092013">
def getError(self, response):
    errName = self.extract(response, "&lt;error&gt;", "&lt;/error&gt;")
    errName = errName.strip()
    if errName in OpenomyError.CODES:
        return OpenomyError.CODES[errName]
    return -1

</t>
<t tx="adam.20070203191141">

def __call__(self, req):
    try:
        # Call the method.
        self.filter(req)
        req.environ['wsgi.response'].headers['Content-Type'] = req.file.contentType
        req.environ['wsgi.response'].write(req.storedFile.getData())
        
    except OpenomyError, f:
        req.environ['wsgi.response'].status_code = 400
        req.environ['wsgi.response'].failure = f
        return self._failure(req)


</t>
<t tx="adam.20070203191141.1">

def filter(self, req):
    # Check the file token
    fv = req.params
    fileToken = req.fileToken = fv.get('fileToken', None)

    req.fileUser = FileUser.select(req.db, 
                                   fields=['fileToken'], 
                                   vals=[fileToken], 
                                   single=True)
                                   
    if req.fileUser == ():
        raise OpenomyError(ERR_UNAUTHORIZED)
        
    req.file = File.select(req.db, 
                           vals=["==%i" % req.fileUser.fileID], 
                           single=True)
    if not req.file:
        raise OpenomyError(ERR_UNAUTHORIZED)
        
    req.storedFile = StoredFile.instance(req.file)
    
    
</t>
<t tx="adam.20070207093632"># openomy_test.py
""" openomy_test.py - Testing for the python openomy client and server.
    
    @version    0.1
    @summary    This pretends to be both client and server,
                testing pretty much the entire API.
    @author       CptnAhab &lt;cptnahab@gmail.com&gt;
    @copyright    (C) 2006-2007 CptnAhab
    @license      Free Software.  See LICENSE.txt for details.
    
"""
&lt;&lt; imports &gt;&gt;

@others

</t>
<t tx="adam.20070207101731"></t>
<t tx="adam.20070207115944">

# Ripped off from Python2.5 wsgiref.util
def setupTestingDefaults(self, environ):

    environ.setdefault("SERVER_SOFTWARE", "Fake WSGI Server")
    environ.setdefault('SERVER_NAME','127.0.0.1')
    environ.setdefault('SERVER_PROTOCOL','HTTP/1.0')

    environ.setdefault('HTTP_HOST',environ['SERVER_NAME'])
    environ.setdefault('REQUEST_METHOD','GET')

    if 'SCRIPT_NAME' not in environ and 'PATH_INFO' not in environ:
        environ.setdefault('SCRIPT_NAME','')
        environ.setdefault('PATH_INFO','/')

    environ.setdefault('wsgi.version', (1,0))
    environ.setdefault('wsgi.run_once', 0)
    environ.setdefault('wsgi.multithread', 0)
    environ.setdefault('wsgi.multiprocess', 0)

    from StringIO import StringIO
    environ.setdefault('wsgi.input', StringIO(""))
    environ.setdefault('wsgi.errors', StringIO())
    environ.setdefault('wsgi.url_scheme', "HTTP")

    if environ['wsgi.url_scheme']=='http':
        environ.setdefault('SERVER_PORT', '80')
    elif environ['wsgi.url_scheme']=='https':
        environ.setdefault('SERVER_PORT', '443')



</t>
<t tx="adam.20070207123001">

class Debug:
    """ Various debugging functions. """
    
    @others


</t>
<t tx="adam.20070207125315">

def CreateApplication(cls, name=None, version=None, 
                      description=None, ownerID=None, 
                      config=None):

    if name is None: 
        appName = API.getConfigParam('appName', config)
    if version is None: 
        version = API.getConfigParam('appVersion', config)
    if description is None: 
        description = API.getConfigParam('appDescription', config)
    if ownerID is None: 
        ownerID = API.getConfigParam('appOwnerID', config)
    
    params = { "method": "Debug.CreateApplication",
               "name": name,
               "version": version,
               "description": description,
               "ownerID": ownerID }
    
    response = API.dispatch(params, config=config, cfm=False)
    if not response:
        return False

    appKey = API.extract(response, "&lt;applicationKey&gt;", 
                             "&lt;/applicationKey&gt;")
    privKey = API.extract(response, "&lt;privateKey&gt;", 
                             "&lt;/privateKey&gt;")
                             
    return (appKey, privKey)

CreateApplication = classmethod(CreateApplication)</t>
<t tx="adam.20070207131632">

# Debug.Reinitialize: Delete everything.
Debug.Reinitialize()


### Account testing

# Debug.CreateApplication: Get a new application key.
appKey, privKey = Debug.CreateApplication()
    
myConfig.set('applicationKey', appKey)
myConfig.set('privateKey', privKey)

# Auth.RegisterUser: Register a User and Session
myConfig.set("username", "testuser")
myConfig.set("password", "testing123")
myConfig.set("email", "test@example.com")
cfmToken = Auth.RegisterUser()

# Auth.AuthorizeUser: Authorize a User Session
cfmToken = Auth.AuthorizeUser()
myConfig.set('confirmedToken', cfmToken)

# Save the config info
myConfig.save()


</t>
<t tx="adam.20070207131632.1">### Test setup

# Specialized configuration
myConfig = Configuration(path="./testing",
                         name="openomy-test.ini",
                         default=True)
myConfig.save(format=Configuration.FORMAT_INI)


# Application info
myConfig.set("appName", "openomy_test")
myConfig.set("appVersion", "1.0")
myConfig.set("appDescription", "Openomy Client/Server Testing Application")
myConfig.set("appOwnerID", 0)

# Server info
myConfig.set("apiBase", "http://localhost:9009/openomy")

# TODO: Create some data files for uploading



# Create a fake WSGI server
wsgiServer = FakeWSGIServer(Service())

# Create a fake urlopener
API.urlopen = wsgiServer.urlopen

# Set up the server testing environment
wsgiServer.defaultEnviron['OPENOMY_APP_ROOT'] = '/openomy'
tblPath = KirbyObject.PATH = './testing/tables'
if not os.path.exists(tblPath):
    os.makedirs(tblPath)
filePath = StoredFile.PATH = './testing/files'
if not os.path.exists(filePath):
    os.makedirs(filePath)
</t>
<t tx="adam.20070207131754">

class FakeWSGIServer:
    """ Make-believe WSGI server, for testing. """
    
    defaultEnviron = None
    app = None
    
    requestEnviron = None
    
    responseStatus = None
    responseHeaders = None
    responseOutput = None
    
    def __init__(self, app):
        environ = self.defaultEnviron = dict()
        self.setupTestingDefaults(environ)
        
        self.app = app
        


    @others


</t>
<t tx="adam.20070207133213">


# Ripped off from cherrypy.wsgiserver.__init__

comma_separated_headers = ['ACCEPT', 'ACCEPT-CHARSET', 'ACCEPT-ENCODING',
    'ACCEPT-LANGUAGE', 'ACCEPT-RANGES', 'ALLOW', 'CACHE-CONTROL',
    'CONNECTION', 'CONTENT-ENCODING', 'CONTENT-LANGUAGE', 'EXPECT',
    'IF-MATCH', 'IF-NONE-MATCH', 'PRAGMA', 'PROXY-AUTHENTICATE', 'TE',
    'TRAILER', 'TRANSFER-ENCODING', 'UPGRADE', 'VARY', 'VIA', 'WARNING',
    'WWW-AUTHENTICATE']

quoted_slash = re.compile("(?i)%2F")

def parseRequest(self, request, environ):
    """Parse the next HTTP request start-line and message-headers."""

    environ["REQUEST_METHOD"] = request.get_method()
    
    path = request.get_full_url()
    scheme, location, path, params, qs, frag = urlparse(path)

    environ["wsgi.url_scheme"] = scheme

    environ["SERVER_NAME"] = location
    if ':' in location:
        l, environ["SERVER_PORT"] = location.split(":", 1)

    if params:
        path = path + ";" + params
    
    atoms = [unquote(x) 
             for x in self.quoted_slash.split(path)]
    path = "%2F".join(atoms)
    environ["PATH_INFO"] = path

    environ["QUERY_STRING"] = qs
    
    # then all the http headers
    for k, v in request.header_items():
        k, v = k.strip().upper(), v.strip()
        envname = "HTTP_" + k.replace("-", "_")
        
        if (k in self.comma_separated_headers 
            and envname in environ):
            v = ", ".join(environ[envname], v,)
        environ[envname] = v
        
    ct = environ.pop("HTTP_CONTENT_TYPE", None)
    if ct: environ["CONTENT_TYPE"] = ct
    environ.pop("HTTP_CONTENT_LENGTH", None)

    bodyData = request.get_data()
    if bodyData is None: bodyData = ""
    environ['wsgi.input'] = StringIO(bodyData)
    environ['CONTENT_LENGTH'] = len(bodyData)
    environ['wsgi.input'].length = environ['CONTENT_LENGTH']


</t>
<t tx="adam.20070207141345">

class Response(StringIO):
    responses = BaseHTTPRequestHandler.responses
    
    def __init__(self, url, status, headers, output):
            
        StringIO.__init__(self, output)

        self.url = url
        statuscode, msg = status.split(" ", 1)
        self.status = int(statuscode)
        self.msg = msg
        self.headers = headers

        if self.status &gt;= 300 or self.status &lt; 200:
            print output
            raise urllib2.HTTPError(self.url, 
                                self.status,
                                self.msg,
                                self.headers,
                                self)
    
    
    def geturl():
        return self.url



</t>
<t tx="adam.20070207144556">


def urlopen(self, request):        
    # Convert string urls to Request objects
    if type(request) in (str, unicode):
        request = urllib2.Request(request)

    environ = self.requestEnviron = dict(self.defaultEnviron)
    self.responseHeaders = dict()
    self.responseStatus = 500
    self.responseOutput = None
    
    self.parseRequest(request, environ)
    
    self.responseOutput = self.app(environ, 
             self.handleResponseStart)
             
    self.responseOutput = ''.join(self.responseOutput)
                         
    return self.Response(request.get_full_url(),
                         self.responseStatus,
                         self.responseHeaders,
                         self.responseOutput)
    


</t>
<t tx="adam.20070207144800">


def handleResponseStart(self, status, headers):
    responseHeaders = dict(headers)
    self.responseHeaders.update(responseHeaders)
    self.responseStatus = status
    

</t>
<t tx="adam.20070207145205">

# WSGI-based Openomy App service
from openomy_server import Service, KirbyObject, StoredFile

# Openomy client
from openomy import Auth, Files, Tags, API, Configuration

# HT without the TP
import urllib2, re, os
from urlparse import urlparse
from rfc822 import unquote
from BaseHTTPServer import BaseHTTPRequestHandler
from StringIO import StringIO

</t>
<t tx="adam.20070207145327"></t>
<t tx="adam.20070207145327.1">

### Begin File testing

# Files.GetAllFiles: Get a list of User's Files
files = Files.GetAllFiles()
if len(files) &gt; 0:
    raise "Too many files: expecting 0, received %i" % len(files)

# Files.AddFile: Upload a File
fileAdded = Files.AddFile(filename="openomy_test.py")
if fileAdded is False:
    raise "File upload failure."

# Files.GetAllFiles: Get a list of User's Files
files = Files.GetAllFiles()
if len(files) != 1:
    raise "Wrong number of files: expecting 1, received %i" % len(files)

fileID = files[0][1]
fileName = files[0][2]
    
# Files.GetFile: Retrieve a File's info
file = Files.GetFile(fileID=fileID)
if file is False:
    raise "Failed to GetFile '%s'." % fileName


# Download: Retrieve a File's contents
downurl = "%(baseurl)s?fileToken=%(filetoken)s" % file
contents = wsgiServer.urlopen(downurl).read()
if contents != open(fileName).read():
    raise "Contents don't match!"
    

# Files.ModifyFile: Overwrite a File
if not Files.ModifyFile(fileID=fileID,
                        filename='./testing/openomy-test.ini'):
    raise "File modification failure."

# Files.GetFile: Retrieve a File's info
file = Files.GetFile(fileID=fileID)

# Download: Retrieve a File's contents
fileName = "./testing/openomy-test.ini"
downurl = "%(baseurl)s?fileToken=%(filetoken)s" % file
contents = wsgiServer.urlopen(downurl).read()
if contents != open(fileName).read():
    raise "Contents don't match!"

# Files.DeleteFile: Remove a File and its contents
if not Files.DeleteFile(fileID=fileID):
    raise "File deletion failure."

# Files.GetAllFiles: Get a list of Users's Files
files = Files.GetAllFiles()
if len(files) != 0:
    raise "Wrong number of files: expecting 0, received %i" % len(files)


</t>
<t tx="adam.20070207145832">



### Tag testing

# Tags.GetAllTags: Get a list of User's Tags
tags = Tags.GetAllTags()
if len(tags) &gt; 0:
    raise "Too many tags: expecting 0, received %i" % len(tags)


# Tags.CreateTag: Create a Tag for a User
tag = Tags.CreateTag(tagName="test-tag")
if tag is False:
    raise "Failed to create tag 'test-tag'."

# Tags.GetAllTags: Get a list of User's Tags
tags = Tags.GetAllTags()
if len(tags) &lt; 1:
    raise "Wrong number of tags: expecting 1, received %i" % len(tags)

tagID = tags[0][1]
tagName = tags[0][2]

# Files.AddFile: Add a File, with a Tag
fileAdded = Files.AddFile(filename="openomy_test.py", tagID=tagID)
if fileAdded is False:
    raise "File upload failure."
    
files = Files.GetAllFiles()
if len(files) != 1:
    raise "Wrong number of files: expecting 1, received %i" % len(files)

fileID = files[0][1]
fileName = files[0][2]

# Tags.GetTag: Get a list of Users and Files for a Tag
tag = Tags.GetTag(tagID)
if tag is False:
    raise "Failed to retrieve tag '%s'." % tagName

if len(tag['files']) != 1:
    print "Tag: %s" % str(tag)
    raise "Wrong number of files: expecting 1, received %i" % len(tag['files'])

# Tags.DeleteFileFromTag: Remove a File from a Tag
if not Tags.DeleteFileFromTag(tagID, fileID):
    print "Tag: %s" % str(tag)
    raise "Failed to remove file from tag."

# Tags.AddFileToTag: Add a File to a Tag
if not Tags.AddFileToTag(tagID, fileID):
    print "Tag: %s" % str(tag)
    raise "Failed to re-add file to tag."

# Tags.GetTag: Get a list of Users and Files for a Tag
tag = Tags.GetTag(tagID)
if tag is False:
    raise "Failed to retrieve tag '%s'." % tagName

# Tags.DeleteTag: Remove a Tag
if not Tags.DeleteTag(tagID):
    print "Tag: %s" % str(tag)
    raise "Failed to delete tag '%s'." % tagName
</t>
<t tx="adam.20070207145832.1">

### Finish file testing


# Files.GetAllFiles: Get a list of Users's Files
files = Files.GetAllFiles()
if len(files) != 1:
    raise "Wrong number of files: expecting 1, received %i" % len(files)
    
# Files.DeleteFile: Remove a File and its contents
if not Files.DeleteFile(files[0][1]):
    raise "Failed to delete file '%s'." % files[0][2]

# Files.GetAllFiles: Get a list of Users's Files
files = Files.GetAllFiles()
if len(files) != 0:
    print str(files)
    raise "Wrong number of files: expecting 0, received %i" % len(files)


### ALL DONE
print "Passed all tests."

</t>
<t tx="adam.20070208125522">

def Reinitialize(cls, config=None):

    params = { "method": "Debug.Reinitialize" }
    
    response = API.dispatch(params, config=config, cfm=False)
    if not response:
        return False

    return True

Reinitialize = classmethod(Reinitialize)

</t>
<t tx="adam.20070209083233">

def getConfigParam(self, paramName, config=None):
    """ Retrieve a param value from one of the three
    possible configuration sources. """
    
    for cfg in (config, self.userConfig, self.config):
        if not cfg: continue

        paramValue = cfg.get(paramName)
        if paramValue is not None:
            break
            
    return paramValue
    


</t>
<t tx="adam.20070209090343">


def __init__(self, application=None, mode=MODE_TEST):
    # Create the root dispatcher
    self.dispatcher = dp = application or URLMap()
    
    # Create and bind the REST applications
    restApi = {
        "Auth": Auth,
        "Tags": Tags,
        "Files": Files
        }
        
    if mode == MODE_TEST:
        restApi['Debug'] = Debug
        
    dp[None, '/api/rest'] = REST(**restApi)

    # Create and bind the download application
    dp[None, '/api/download'] = Download()
    
    wsgi_app = HTTPExceptionHandler(self)

    if mode == MODE_PRODUCTION:
        wsgi_app = ErrorMiddleware(wsgi_app)
    else:
        wsgi_app = ErrorMiddleware(wsgi_app, debug=True)
        wsgi_app = TransLogger(wsgi_app)

    # Us, all wrapped up.
    self.wsgi_app = wsgi_app



</t>
<t tx="adam.20070209090343.1">
    
def __call__(self, environ, start_response):
    """ Dispatch to the applications """
    req = Request(environ)
    app = self.dispatcher[environ['PATH_INFO']]
    
    app(req)
    
    response = environ['wsgi.response']
    status, headers, output = response.wsgi_response()

    start_response(status, headers)
    return output


</t>
<t tx="ahab.20060403130903"></t>
<t tx="ahab.20060403130903.1">@language html
@wikibase http://documentation.openomy.com/index.php
</t>
<t tx="ahab.20060403130903.2">#!/usr/bin/python
""" openomy-python: Python bindings for the Openomy REST API

    @version    0.5
    @license    Free Software.  See LICENSE.TXT for details.
    @copyright  Copyright (C) 2005-2006 Manpreet Singh 
                    &lt;manpreet_singh@users.sourceforge.net&gt;
    @copyright  Copyright (C) 2006-2007 CptnAhab 
                    &lt;cptnahab@gmail.com&gt;

    Version History
    ===============
    v0.5 : CptnAhab 2007-02-07
         Integrated AutoLoginUser and AutoRegisterUser
            into User, added Configuration items
         Re-throws Server Exceptions
         Tested with Python Server and FUSE bindings
         Fixed RFC1891 request packing
    v0.4 : CptnAhab 2006-05-20
         Added Auth.AuthorizeUser and
            Auth.RegisterUser
    v0.2 : CptnAhab 2006-03-19
         Slight refactoring
    v0.1 : Manpreet Singh 2006-01-02
         First release

    TODO
    ===============
    * Unit tests
    * Deferred responses from API
    * Logging integration?
"""

&lt;&lt; openomy declarations &gt;&gt;

@others
</t>
<t tx="ahab.20060403130903.3"># Basic imports
import os, sys

# For GET and POST requests
import urllib, urllib2

# For file uploading (fileup)
import mimetools, mimetypes

# For fileup and local caching
import time

# For file downloading and local caching
import calendar

# For opening the authorization link
import webbrowser

# For signing messages
import md5

# YAML configuration processing
try:
    import yaml
except ImportError:
    yaml =  None

# INI configuration processing
import ConfigParser    

# for locating SYSCONF
import platform

# For regex-style parsing
import re

</t>
<t tx="ahab.20060403130903.4">


class DefaultConfiguration:
    """ A simple namespace class for hard-coded
    default API configuration. """

	&lt;&lt; declarations &gt;&gt;

	@others


</t>
<t tx="ahab.20060403130903.5"># The hard-coded default server info.  This is
# the URL portion before "/api".
apiBase = "http://www.openomy.com"     # For default server
# apiBase = "http://localhost:9009"    # For local stand-alone server
# apiBase = "http://localhost/openomy" # For local mod_python server

# The hard-coded default application details
appName = "Openomy-Python Client"
appVersion = "0.5"
appDescription = "Python client for accessing Openomy API endpoints."
appOwnerID = 0

# The hard-coded default application key,
# private key, and confirmed token.  Private
# keys and confirmed tokens MUST NOT be
# accessible to anyone but the app owner.
applicationKey = None
privateKey = None
confirmedToken = None


# The hard-coded default username, password
# and e-mail.  You probably don't want these in
# the source code, but here's a spot just in
# case.
username = None
password = None
email = None
</t>
<t tx="ahab.20060403130903.6">

def get(cls, attr):
    """ Retrieve a configuration parameter """
    return cls.__dict__.get(attr, None)
get = classmethod(get)</t>
<t tx="ahab.20060403130903.7">
def set(cls, attr, val):
    """ Set a configuration parameter """
    cls.__dict__[attr] = val
    return val
set = classmethod(set)</t>
<t tx="ahab.20060403130903.8">



class Configuration:
    """ Simple openomy configuration management.
    Stores configuration in-memory and persists to
    a specified location, in either Yaml or INI. """

	&lt;&lt; declarations &gt;&gt;

	@others


</t>
<t tx="ahab.20060403130903.9">FORMAT_ANY = -1
if yaml:
    FORMAT_DEF = 1
else:
    FORMAT_DEF = 2
FORMAT_YAML = 1
FORMAT_INI = 2

# this is the correct case because
# INI is case insensitive in attr
# names
ATTR_NAMES = ( "applicationKey",
               "privateKey",
               "confirmedToken",
               "username",
               "password",
               "email",
               "appName",
               "appDescription",
               "appVersion",
               "appOwnerID",
               "apiBase" )
ATTR_KEYS = [k.lower() for k in ATTR_NAMES]

_path = None
_name = "openomy"
_values = None

</t>
<t tx="ahab.20060403130903.10">def __init__(self, path=None, name=None, default=False):  
    """ Create a new configuration object. """
    self._path = path
    self._name = name
    self._values = dict()
    if default:
        API.userConfig = self
</t>
<t tx="ahab.20060403130903.11">def get(self, attr):
    """ Retrieve a configuration parameter """
    return self._values.get(attr, None)
</t>
<t tx="ahab.20060403130903.12">def save(self, path=None, name=None, format=FORMAT_DEF):
    """ Store the configuration directives
    for APP or USER to a file. """
    
    if format not in (Configuration.FORMAT_YAML, 
                      Configuration.FORMAT_INI):
        # Set the format
        format = Configuration.FORMAT_DEF

    # Make sure we have a path
    if not path:
        path = self._path or os.getcwd()
    
    # Make sure the path exists        
    if not os.path.isdir(path):
        # This will raise an exception for us
        os.makedirs(path)
    
    # Make sure we have a name
    if not name:
        name = self._name or Configuration._name
    
    ext = os.path.splitext(name)[1]
    if ext == "":
        ext = [ "", ".yml", ".ini" ][format]
    else:
        ext= ""
        
    filename = os.path.join(path, name)
    if not os.path.exists(filename):
        # Add an extension if we can
        filename += ext

    if format == Configuration.FORMAT_YAML:
        if yaml:
            
            yfile = file(filename, "w")
            
            # write in alpha order
            keys = self._values.keys()
            keys.sort()
            for key in keys:
                yline = "%s: %s\n" % (key, self._values[key])
                yfile.write(yline)
            
            yfile.close()
            
        else:
            format = Configuration.FORMAT_INI

    if format == Configuration.FORMAT_INI:
        ifile = file(filename, "w")
        
        # write the header
        ifile.write("[Openomy]\r\n")
        
        # write in alpha order
        keys = self._values.keys()
        keys.sort()
        for key in keys:
            iline = "%s=%s\r\n" % (key, self._values[key])
            ifile.write(iline)
        
        ifile.close()
        
    return True
</t>
<t tx="ahab.20060403130903.13">def set(self, attr, val):
    """ Set a configuration parameter """
    strval = str(val)
    self._values[attr] = strval
    if not attr.startswith("_"):
        # for easy attribute access
        setattr(self, attr, strval) 
    return val
</t>
<t tx="ahab.20060403130903.14">def load(self, path=None, name=None, format=FORMAT_ANY):
    """ Load the configuration directives
    for APP or USER from a file. """
    
    if format not in (Configuration.FORMAT_YAML,
                        Configuration.FORMAT_INI,
                        Configuration.FORMAT_ANY):
        # Set the format
        format = Configuration.FORMAT_DEF
    
    if not path:
        path = self._path or os.getcwd()
            
    if not name:
        name = self._name
        if not name:
            name = Configuration._name
        
    filename = os.path.join(path, name)
    if not os.path.exists(filename):
        exts = {}
        if format in (Configuration.FORMAT_ANY,
                      Configuration.FORMAT_INI):
            exts[Configuration.FORMAT_INI] = ".ini"
        if format in (Configuration.FORMAT_ANY,
                      Configuration.FORMAT_YAML):
            exts[Configuration.FORMAT_YAML] = ".yml"
        
        tried = [filename]
        basename = filename
        found = None
        for format, ext in exts.items():
            filename = basename + ext
            if os.path.exists(filename):
                found = filename
                break
            else:
                tried.append(filename)
    
        if not found:
            # SOL
            print "Could not locate file to load. Attempted:"
            for t in tried:
                print "\t%s" % t
            return False

    if format in (Configuration.FORMAT_YAML,
                  Configuration.FORMAT_ANY):
        tyaml = file(filename).read()
        config = yaml.load_document(tyaml)
        if not isinstance(config, dict):
            print "Invalid YAML configuration."
            print "Document must be a map."
        
        else:
            # We succeeded.
            format = Configuration.FORMAT_YAML

    if format in (Configuration.FORMAT_INI,
                  Configuration.FORMAT_ANY):
        
            # Use the ini loader
            cparser = ConfigParser.ConfigParser()
            cparser.read(filename)
            config = cparser.items("Openomy")
            if not isinstance(config, list):
                print "Invalid INI configuration file."
                return False

            config = dict(config)
            
            # Clean up the attribute names    
            outConfig = dict()
            for key, val in config.items():
                try:
                    # see if it should be normalized
                    nKey = self.ATTR_KEYS.index(key)
                    key = self.ATTR_NAMES[nKey]
                except ValueError:
                    # leave it alone
                    continue
                outConfig[key] = val
                   
            config = outConfig

    # Remember the config data we just loaded
    for key in config:
        self.set(key, config[key])
    return config
</t>
<t tx="ahab.20060403130903.15">




class _API:
    """ Implements the REST api calling mechanism. """

	&lt;&lt; declarations &gt;&gt;

	@others

API = _API()


</t>
<t tx="ahab.20060403130903.16">REST = "/api/rest/"
DOWNLOAD = "/api/download/"
LOGIN = "/api/login/"

config = DefaultConfiguration

# Holds default user configuration
userConfig = None

# Overridable urlopen (as per Google In-Stall Pamphlet)
urlopen = staticmethod(urllib2.urlopen)</t>
<t tx="ahab.20060403130903.17">
def sign(self, params, config=None, cfm=True):
    """ sign a list of parameters after applying
    keys and tokens """

    # Get the appKey and privateKey
    appKey = self.getConfigParam('applicationKey', config)
    privKey = self.getConfigParam('privateKey', config)
            
    if not (appKey and privKey):
        # can't sign without those
        return False

    params['applicationKey'] = appKey

    # Get the confirmedToken
    if cfm:
        cfmToken = self.getConfigParam('confirmedToken', config)

        if not cfmToken:
            # can't do that, either
            return False

        params['confirmedToken'] = cfmToken
   
    # Create a signature
    keylist = params.keys()
    keylist.sort()
    sigdat = "".join([ "%s=%s" % (str(k), str(params[k]))
                       for k in keylist ])
    sigdat += privKey
    sig = md5.new(sigdat).hexdigest()

    params['signature'] = sig
    return sig


</t>
<t tx="ahab.20060403130903.18">
def getUrl(self, params, baseurl=REST, config=None, cfm=True):
    """ Encode a GET request url """
    lclparms = dict(params)
    
    signed = self.sign(lclparms, config=config, cfm=cfm)
    if cfm and not signed:
        return False

    apiBase = self.getConfigParam('apiBase', config)
    url =  apiBase + baseurl + "?" + urllib.urlencode(lclparms)       
    #print "URL: %s" % url
    return url



</t>
<t tx="ahab.20060403130903.19"># From: http://berserk.org/uploadr/

def getRequest(self, params, url, files, config=None, cfm=True):
    """ Build a POST request """

    # Collect our thoughts before the journey
    lclparms = dict(params)
    signed = self.sign(lclparms, config=config, cfm=cfm)
    if cfm and not signed:
        return False


    # Create the MIME boundary text
    bound = '-----'+mimetools.choose_boundary()+'-----'
    
    # Grow the body inch by inch, line by line
    L = list()    
    
    # Add the form parameters
    for key in lclparms:
        L.append('--' + bound)
        L.append('Content-Disposition: form-data; name="%s"' % key)
        L.append('')
        L.append(lclparms[key])
    
    # Add the files
    for (key, filename, value) in files:
        filetype = mimetypes.guess_type(filename)[0] or 'application/octet-stream'
        L.append('--' + bound)
        L.append('Content-Disposition: form-data; name="%s"; filename="%s"' % (key, filename))
        L.append('Content-Type: %s' % filetype)
        L.append('')
        L.append(value)

    # Close the MIME envelope
    L.append('--' + bound + '--')
    L.append('')

    # Form a single body string
    body = '\r\n'.join(L)

    # And generate the request object.
    headers = dict()
    headers['Content-type'] = 'multipart/form-data; boundary=' + bound
    headers['Content-length'] = str(len(body))
    
    apiBase = self.getConfigParam('apiBase', config)
    return urllib2.Request(apiBase + url, body, headers)


</t>
<t tx="ahab.20060403130903.20">
def dispatch(self, params, 
             baseurl=REST, 
             files=None, 
             config=None,
             cfm=True):
    """ Dispatch an API request to the server. """

    if files:
        # POST em
        req = self.getRequest(params, baseurl, files, config=config, cfm=cfm)
        urlopen = _API.urlopen
        f = urlopen(req)
        response = f.read()
        
    else:
        # GET it
        url = self.getUrl(params, baseurl, config=config, cfm=cfm)
        urlopen = _API.urlopen
        f = urlopen(url)
        response = f.read()
        
    # Failure implies failure.
    if not self.succeeded(response):
        errCode = self.getError(response)
        raise OpenomyError(errCode)
        
    return response


</t>
<t tx="ahab.20060403130903.21">
def succeeded(self, response):
    return -1 != response.find("&lt;success&gt;")

</t>
<t tx="ahab.20060403130903.22">
def extract(self, haystack, beforeneedle, afterneedle):
    """ Extract a needle from the haystack string 
        based on the surrounding context """
        
    pos1 = haystack.find(beforeneedle) + len(beforeneedle)
    pos2 = haystack.find(afterneedle, pos1)
    return haystack[pos1:pos2]
    

</t>
<t tx="ahab.20060403130903.23">
def extractObjects(self, response, tagname=None):
    # Find any objects at all.
    # groups: 1-type, 2-id, 3-name
    robj = re.compile('&lt;(?P&lt;tag&gt;.+) id="([^"]+)"[^&gt;]*&gt;([^&lt;]*)&lt;/(?P=tag)&gt;', re.I)

    # somewhere to put our objects
    objects = list()

    # Do the match (the monster match)
    matches = robj.findall(response)
    for ob in matches:
        # only match tagname
        if tagname and ob[0] != tagname:
            continue
        objects.append(ob)
    
    return objects


</t>
<t tx="ahab.20060403130903.24">
def extractFields(self, response):
    """ Extract &lt;tag attrs&gt;data&lt;/tag&gt; from
    an Openomy response. """

    # Find any field at all
    robj = re.compile("&lt;(?P&lt;tag&gt;[^&gt;]+)\s?(\S+?)?&gt;(.*)&lt;/(?P=tag)&gt;", re.I)

    # Find all of the fields
    matches = robj.findall(response)
    fields = dict()
    for match in matches:
        tag, text = match[0], match[2]
        # TODO: xml attrs - group 1
        fields[tag] = text
    
    return fields


</t>
<t tx="ahab.20060403130903.25">
def extractId(self, response, id_string):
    """ Pull out an id attribute. """

    pos1 = response.find(id_string)
    id0 = pos1 + len(id_string) + 2
    id1 = response.find('"', id0)
    
    return response[id0:id1]    


</t>
<t tx="ahab.20060403130903.26">




class _Auth:
    """ Methods to make sure that only the 
    right users and applications can talk 
    to each other. """
    
    def __init__(self, API):
        self.API = API
        
	@others

Auth = _Auth(API)

</t>
<t tx="ahab.20060403130903.30">
def GetUnconfirmedToken(self, config=None):
    """ Initiate a session for an application. """
    
    params = { "method": "Auth.GetUnconfirmedToken" }

    response = API.dispatch(params, cfm=False, config=config)
    if not response:
        return False

    return API.extract(response, "&lt;unconfirmedtoken&gt;", 
                             "&lt;/unconfirmedtoken&gt;")


</t>
<t tx="ahab.20060403130903.31">
def GetConfirmedToken(self, uncfmToken, config=None):
    """ Attempt to obtain a confirmedToken
    authorizing access to a user account. """

    params = { "method": "Auth.GetConfirmedToken",
               "unconfirmedToken": uncfmToken }

    response = API.dispatch(params, cfm=False, config=config)
    if not response:
        return False
        
    cfmToken = API.extract(response, "&lt;confirmedtoken&gt;", 
                                 "&lt;/confirmedtoken&gt;")

    return cfmToken


</t>
<t tx="ahab.20060403130903.32">



class _Files:
    """ Methods to perform actions on files. """
    
    def __init__(self, API):
        self.API = API
        
	@others

Files = _Files(API)
</t>
<t tx="ahab.20060403130903.34">
def GetFile(self, fileID, timeout=None, config=None):
    """ Load the details about a file from 
    Openomy, and obtain a download link. """
    
    params = { "method": "Files.GetFile",
               "fileID": fileID }
    
    if timeout:
        params["timeout"] = timeout
    
    response = API.dispatch(params, config=config)
    if not response:
        return False
    
    # Collect the attributes from the response
    fileinfo = API.extractFields(response)

    # Keep the id
    fileinfo["id"] = fileID

    # Get the size units
    fileinfo["sizeunits"] = API.extract(response,
                        '&lt;size units="', '"&gt;')
    
    return fileinfo


</t>
<t tx="ahab.20060403130903.35">
def AddFile(self, filename, tagID=None, config=None):
    """ Create a file on openomy from the local
    file 'filename'. """
                            
    params = { "method": "Files.AddFile" }
    if tagID:
        params['tagID'] = tagID

    upload_files = [('fileField',
                    os.path.basename(filename),
                    file(filename, 'rb').read())]

    response = API.dispatch(params,
                            files=upload_files,
                            config=config)
    if not response:
        return False

    # Return the newly created file id.
    return API.extractId(response, "file id")


</t>
<t tx="ahab.20060403130903.36">
def DeleteFile(self, fileID, config=None):
    """ Deletes the given file from Openomy. """ 
    
    params = { 'method': "Files.DeleteFile",
               'fileID': fileID }

    return not not API.dispatch(params, config=config)


</t>
<t tx="ahab.20060403130903.37">
def ModifyFile(self, fileID, filename, config=None):
    """ Create a file on openomy from the local
    file 'filename'. """
   
    params = { "method": "Files.ModifyFile",
               "fileID": fileID }

    upload_files = [('fileField',
                    os.path.basename(filename),
                    file(filename, 'rb').read())]

    return not not API.dispatch(params,
                                files=upload_files,
                                config=config)


</t>
<t tx="ahab.20060403130903.38">
def GetAllFiles(self, config=None):
    """ Retrieve all the files for a user. """

    params = { "method":  "Files.GetAllFiles" }

    response = API.dispatch(params, config=config)
    if not response:
        return False

    return API.extractObjects(response, "file")



</t>
<t tx="ahab.20060403130903.39">



class _Tags:
    """ Methods to perform actions on tags. """
    
    def __init__(self, API):
        self.API = API
    
	@others

Tags = _Tags(API)</t>
<t tx="ahab.20060403130903.41">
def GetAllTags(self, config=None):
    """ Retrieves a list of all the tags for a user.
    This includes tags the user has created as well 
    as tags the user was invited to (and accepted). 
    """

    params = { "method":  "Tags.GetAllTags" }

    response = API.dispatch(params, config=config)
    if not response:
        return False

    return API.extractObjects(response, "tag")



</t>
<t tx="ahab.20060403130903.42">
def GetTag(self, tagID, config=None):
    """ Gets information, including the name, 
    the date created, the files within, the 
    id, etc. about the tag in question. """
    
    params = { "method": "Tags.GetTag",
               "tagID": tagID }

    response = API.dispatch(params, config=config)
    if not response:
        return False
        
    rtag = re.compile('&lt;tag\s+id="([^"]+?)"\s+name="([^"]+?)"\s+created="([^"]+?)"\s*&gt;', re.I)
    tag = dict()

    # Do the match (the monster match)
    matches = rtag.findall(response)
    for groups in matches:
        tag["id"] = groups[0]
        tag["name"] = groups[1]
        tag["created"] = groups[2]

    # TODO: extract the attributes
    tag["files"] = API.extractObjects(response, "file")
    # TODO: extract the attributes
    tag["users"] = API.extractObjects(response, "user")

    return tag



</t>
<t tx="ahab.20060403130903.43">
def CreateTag(self, tagName, config=None):
    """ Creates a new tag associated with a user. """
    
    params = { "method": "Tags.CreateTag",
               "tagName": tagName }

    response = API.dispatch(params, config=config)
    if not response:
        return False
        
    return API.extractId(response, "tag id")


</t>
<t tx="ahab.20060403130903.44">
def DeleteTag(self, tagID, config=None):
    """ Deletes a tag if the user is an admin
    or creator of the tag. """

    params = { "method": "Tags.DeleteTag",
               "tagID": tagID }
        
    return not not API.dispatch(params, config=config)


</t>
<t tx="ahab.20060403130903.45">
def AddFileToTag(self, tagID, fileID, config=None):
    """ Adds a file to a specific tag. """

    params = { "method": "Tags.AddFileToTag",
               "tagID": tagID,
               "fileID": fileID }

    return not not API.dispatch(params, config=config)




</t>
<t tx="ahab.20060403130903.46">
def DeleteFileFromTag(self, tagID, fileID, config=None):
    """ Deletes a file from a specific tag. """
    
    params = { "method": "Tags.DeleteFileFromTag",
               "tagID": tagID,
               "fileID": fileID }
             
    return not not API.dispatch(params, config=config)


</t>
<t tx="ahab.20060403130903.47">
class RemoteProxy:
    """ Base type for proxying remote objects
    belonging to some master object. """
	&lt;&lt; class RemoteProxy declarations &gt;&gt;
	@others
</t>
<t tx="ahab.20060403130903.48">_owner = None
_remote = None
_loaded = False

</t>
<t tx="ahab.20060403130903.49">def __init__(self, owner, refresh=True, **kwargs):
    self._owner = owner
    if not self._remote:
        self._remote = dict()
    self.__dict__.update(kwargs)
    if refresh:
        self.refresh()
</t>
<t tx="ahab.20060403130903.50">

def __getattr__(self, name):
    """ Check for capwords/uscore notation """
    
    # Python attribute name trickery
    # automatically finds "getTag" when you 
    # use ob.GetTag or ob.get_tag
    if name[0] != name[0].lower():
        return getattr(self, name[0].lower() + name[1:])
    elif "_" in name and not name[0] == "_":
        name = re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), name)
        return getattr(self, name)
    else:
        raise AttributeError, name
</t>
<t tx="ahab.20060403130903.51">def refresh(self):
    """ Placeholder. """
    self._loaded = False
    return False
</t>
<t tx="ahab.20060403130903.52">def _updated(self, obtype, obdefs):
    """ Notifies the object that its collection
    contents have been updated. """

    if obtype not in self._remote:
        # we don't care.
        return False

    # What are we comparing to?
    remobs = dict(self._remote[obtype][0])

    # Add the new objects
    ret = list()
    for tobj in obdefs:
        # Prevent the object from being filtered
        # later
        if tobj[1] in remobs:
            rem = remobs[tobj[1]]
            del remobs[rem.id]
            if rem.name in remobs:
                del remobs[rem.name]

        # Get/create and notify everyone
        obj = self._retrieved(*tobj)
        if self != obj._owner:
            self._added(obj)
            obj._added(self)
            
        # return it later
        ret.append(obj)
    
    # Remove the old objects that weren't reloaded
    removed = []
    for key in remobs.keys():
        oldob = remobs[key]
        if oldob.id not in removed:
            removed.append(oldob.id)
            # notification
            self._removed(oldob)
            oldob._removed(self)

    # Return all the objects we obtained.
    return ret


</t>
<t tx="ahab.20060403130903.53">def _retrieved(self, obtype, obid, obname):
    """ Respond to an object retrieval with
    a local RemoteProxy construction. """
    
    # Make sure the owner object is the master
    if self._owner and self != self._owner:
        return self._owner._retrieved(obtype, obid, obname)
       
    # Make sure we have a constructor, etc.
    if obtype not in self._remote:
        return False
    
    # Create or find the object
    
    klass = self._remote[obtype][1]
    obdict = self._remote[obtype][0]
    
    if obid not in obdict:
        ob = klass(self._owner, 
                   refresh=False,
                   id=obid, 
                   name=obname)

        self._added(ob)
        ob._added(self)
    else:
        ob = obdict[obid]
        if obname != ob.name:
            obname, ob.name = ob.name, obname
            self._renamed(ob, obname)

    return ob
</t>
<t tx="ahab.20060403130903.54">def _added(self, object):
    """ Notification of an object added to
    this collection. """

    # Make sure we store this type
    obtype = object.__class__.__name__
    if obtype not in self._remote:
        return False
    
    # Look up the klass name into a tag name
    obtype = self._remote[obtype]
        
    # Store under both id and name
    self._remote[obtype][0][object.id] = object
    self._remote[obtype][0][object.name] = object

    return True

</t>
<t tx="ahab.20060403130903.55">def _renamed(self, object, oldname):
    """ Notification that a collected object
    has been renamed. """
    
    # Make sure we store this type
    obtype = object.__class__.__name__
    if obtype not in self._remote:
        return False

    # Look up the klass name into a tag name
    obtype = self._remote[obtype]
        
    # Remove the old name reference
    del self._remote[obtype][0][oldname]
    
    # Insert a new name reference
    self._remote[obtype][0][object.name] = object

    return True

</t>
<t tx="ahab.20060403130903.56">def _removed(self, object):
    """ Notification of an object removed from
    this collection. """

    # Make sure we store this type
    obtype = object.__class__.__name__
    if obtype not in self._remote:
        return False
        
    # Turn the klass name into a tag name
    obtype = self._remote[obtype]

    # Make sure we have stored the object
    if object.id not in self._remote[obtype][0]:
        return False

    # Remove all references    
    del self._remote[obtype][0][object.id]
    del self._remote[obtype][0][object.name]
    
    return True

</t>
<t tx="ahab.20060403130903.57">
class User(RemoteProxy):
    """ A user (master) proxy object. """
	&lt;&lt; class User declarations &gt;&gt;
	@others
</t>
<t tx="ahab.20060403130903.58">tags = None
files = None
partners = None
config = None
default = True
authLevel = -1

homedir = os.path.expanduser("~")
configdir = os.path.join(homedir, ".openomy")

</t>
<t tx="ahab.20060403130903.59">def __init__(self, default=True, 
                   config=True,
                   auth=True,
                   refresh=True):
    """ Create a user remote proxy """
    
    self.tags = dict()
    self.files = dict()
    self.partners = dict()
    self._remote = { "tag": (self.tags, Tag),
                    "Tag": "tag",
                    "file": (self.files, File),
                    "File": "file",
                    "user": (self.partners, Partner),
                    "Partner": "user" }
    self.config = dict()
    self.default = default
    
    if config:
        self.loadConfig()
    
    if auth:
        auth = self.obtainAccess()

    if (self.authLevel &amp; 3) != 3:
        refresh = False

    RemoteProxy.__init__(self, self, refresh=refresh)
</t>
<t tx="ahab.20060403130903.60">def obtainAccess(self):
    """ Obtain authorization to access Openomy. """
    
    lauth = self.checkAuthLevel()
    
    # We have no keys.
    if (lauth &amp; 2) == 0:
        return self.obtainAppCreds()
        
    # We have no login or confirmed token.
    elif (lauth &amp; 5) == 0:
        return self.obtainCfmToken()

    # We have no confirmed token
    elif (lauth &amp; 1) == 0:
        return self.obtainAppAuth()

    # We already have everything.    
    else:
        return True
</t>
<t tx="ahab.20060403130903.61">def loadConfig(self):
    """ Load the user configuration info. """
 
    parms = { "path": self.configdir }
    if self.default:
        parms["default"] = True

    self.config = Configuration(**parms)
    return self.config.load(format=Configuration.FORMAT_ANY)
</t>
<t tx="ahab.20060403130903.62">def refresh(self):
    """ Do a couple of things. """
    
    self.getAllFiles()
    self.refreshAllTags()
    self._loaded = True
</t>
<t tx="ahab.20060403130903.63">def refreshAllTags(self):
    """ Reload the tag list, and then the file 
    list and other info for each tag. """
    
    tags = self.getAllTags()
    if not tags:
        return False
        
    success = True
    for tag in tags:
        if not tag.refresh():
            success = False
            # oh god don't stop.
            
    return success
</t>
<t tx="ahab.20060403130903.64">def refreshAllFiles(self):
    """ Reload the file list, and then the file 
    info for each one. """
    
    files = self.getAllFiles()
    if not files:
        return False
        
    success = True
    for file in files:
        if not file.refresh():
            success = False
            # oh god don't stop.
            
    return success
</t>
<t tx="ahab.20060403130903.65">def checkAuthLevel(self):
    """ See what sort of authorization we need
    to do with Openomy. """

    keys = 0
    token = 0
    login = 0
    appKey, privKey, cfmToken, userName, password = (None,) * 5
    for item in (self.config, API.config):

        if not appKey:
            appKey = item.get('applicationKey')
        if not privKey:
            privKey = item.get('privateKey')
        if not cfmToken:
            cfmToken = item.get('confirmedToken')
        if not userName:
            userName = item.get('username')
        if not password:
            password = item.get('password')
        
        # check that appkey and privkey are validish
        if not (isinstance(appKey, (str, unicode))
                and len(appKey) == 32) or \
           not (isinstance(privKey, (str, unicode))
                and len(privKey) == 8):            
            item.set('applicationKey', None)
            item.set('privateKey', None)
        else:
            keys = 2
            
        # check that cfmtoken is validish
        if not (isinstance(cfmToken, (str, unicode))
                and len(cfmToken) == 40):
            # Not valid cfmToken
            item.set('confirmedToken', None)
        else:
            token = 1
            
        # check that the login is validish
        if not (isinstance(userName, (str, unicode))
            and isinstance(password, (str, unicode))):
            item.set('userName', None)
            item.set('password', None)
        else:
            login = 4


    if (self.authLevel &lt; keys + token + login and 
        self.authLevel != -1):
        self.config.save()

    self.authLevel = keys + token + login
    return self.authLevel
</t>
<t tx="ahab.20060403130903.66">def obtainAppCreds(self):
    """ Obtain a full set of credentials for the
    application. """

    # Get an unconfirmed token first
    appToken = Auth.RegisterApplication()
    if not appToken:
        print "Could not get an application token"
        return False

    # Prompt the user to authorize 
    # the app in the browser and respond back
    result = None
    while self.promptToAuthorize(app=appToken):

        # Try to obtain the keys and token
        result = Auth.GetApplicationCredentials(appToken)
        if result:
            break

    if not result:
        print "Could not get application credentials"
        return False        
        
    appkey, privkey, cfmToken = result
    self.config.set('applicationKey', appkey)
    self.config.set('privateKey', privkey)
    self.config.set('confirmedToken', cfmToken)
    self.checkAuthLevel()
    return True
</t>
<t tx="ahab.20060403130903.67">def obtainCfmToken(self):
    """ Obtain a confirmed token for a user who
    already has application/private keys """

    # Get an unconfirmed token first
    uncfmToken = Auth.GetUnconfirmedToken()
    if not uncfmToken:
        print "Could not get an unconfirmed token"
        return False

    # Prompt the user to authorize 
    # the app in the browser and respond back
    cfmToken = None
    while self.promptToAuthorize(uncfm=uncfmToken):
        
        # Try to obtain a confirmed token
        cfmToken = Auth.GetConfirmedToken(uncfmToken)
        if cfmToken:
            break

    if not cfmToken:
        print "Could not get a confirmed token"
        return False        
        
    self.config.set('confirmedToken', cfmToken)
    self.checkAuthLevel()
    return True
</t>
<t tx="ahab.20060403130903.68">def promptToAuthorize(self, app=None, uncfm=None):
    """ Open the authorization URL in a web
    browser, and wait for user confirmation. """

    # where to go?
    if app:
        params = { 'appToken': app }
    else:
        params = { 'unconfirmedToken': uncfm }
    url = API.getUrl(params, baseurl=API.LOGIN, cfm=False)

    # open the browser
    webbrowser.open(url)
    
    # inform the user on the console
    print "Please authenticate at the following url." + \
          "This will allow this application access " + \
          "to your Openomy account:"
          
    print "\n" + url + "\n\n"
    
    # wait for a key press
    ans = raw_input("Press Enter to recheck " + \
                    "confirmation or Ctrl+C " + \
                    "to quit.")
                    
    return True
</t>
<t tx="ahab.20060403130903.69">def addFile(self, localsrc, tag=None):
    """ Adds a file to a users openomy account,
    tagged with the optional tag. """

    params = dict()
    if tag:
        params['tagID'] = tag.id

    fileID = Files.AddFile(localsrc,
                           config=self.config,
                            **params)

    filename = os.path.basename(localsrc)

    # Notify the owner
    ofile = self._retrieved("file", fileID, filename)
    if tag:
        tag._added(ofile)
        ofile._added(tag)
    
    return ofile
</t>
<t tx="ahab.20060403130903.70">def createTag(self, name):
    """ Create a new Tag object. """
    
    tagID = Tags.CreateTag(name, config=self.config)

    # Notify the owner
    return self._retrieved("tag", tagID, name)
</t>
<t tx="ahab.20060403130903.71">def getAllFiles(self):
    """ Retrieve a list of file objects for
    this user. """
    
    files = Files.GetAllFiles(config=self.config)
    return self._updated("file", files)
</t>
<t tx="ahab.20060403130903.72">def getAllTags(self):
    """ Retrieve a list of tag objects for
    this user. """
    
    tags = Tags.GetAllTags(config=self.config)
    return self._updated("tag", tags)
</t>
<t tx="ahab.20060403130903.76">
class Partner(RemoteProxy):
    """ This class represents another user on
    openomy.  You can't act as them, so there
    isn't much here but a data leaf. """
	&lt;&lt; class Partner declarations &gt;&gt;
	@others
</t>
<t tx="ahab.20060403130903.77">tags = None
files = None


</t>
<t tx="ahab.20060403130903.78">def __init__(self, owner, refresh=True, **kwargs):
    self.tags = dict()
    self.files = dict()
    
    self._remote = { "tag": (self.tags, Tag),
                     "Tag": "tag",
                     "file": (self.files, File),
                     "File": "file" }
            
    
    RemoteProxy.__init__(self, owner, refresh, **kwargs)
</t>
<t tx="ahab.20060403130903.79">def refresh(self):
    pass
</t>
<t tx="ahab.20060403130903.80">
class Tag(RemoteProxy):
    """ A tag on openomy. """
	&lt;&lt; class Tag declarations &gt;&gt;
	@others
</t>
<t tx="ahab.20060403130903.81">files = None
partners = None

</t>
<t tx="ahab.20060403130903.82">def __init__(self, owner, refresh=True, **kwargs):
    """ Create a new Tag remote proxy. """

    self.files = dict()
    self.partners = dict()
    self._remote = { "file": (self.files, File),
                     "File": "file",
                     "user": (self.partners, Partner),
                     "Partner": "user" }

    RemoteProxy.__init__(self, owner, refresh, **kwargs)
</t>
<t tx="ahab.20060403130903.83">def refresh(self):
    """ Retrieve the list of files that this
    tag has been applied to. """
    
    taginfo = Tags.GetTag(tagID=self.id,
               config=self._owner.config)

    if not taginfo:
        return False
        
    # Save other attributes
    for attr in taginfo:
        if attr not in ("tags", "files", "partners"):
            setattr(self, attr, taginfo[attr])
        
    # Save our file list
    self._updated("file", taginfo["files"])
    self._updated("user", taginfo["users"])

    self._loaded = True
    return True
</t>
<t tx="ahab.20060403130903.84">def delete(self):
    """ Delete this tag from openomy. """
    
    if not Tags.DeleteTag(tagID = self.id,
               config = self._owner.config):
        return False

    # Notify any local files we're tagging        
    for file in self.files:
        file._removed(self)
        
    # Notify the user so we can uncache, etc.
    self._owner._removed(self)
    
    # Remove our id.
    del self.id
    
    return True
</t>
<t tx="ahab.20060403130903.85">def addFile(self, file):
    """ Attach this tag to a file """
    if file.id in self.files:
        return True


    if not Tags.AddFileToTag(fileID=file.id,
                              tagID=self.id,
                   config=self._owner.config):
        return False
    
    # Add the file to our list
    self._added(file)
    # Vice versa
    file._added(self)
    
    return True
</t>
<t tx="ahab.20060403130903.86">def deleteFile(self, file):
    """ Remove this tag from the file. """
    if file.id not in self.files:
        return False

    if not Tags.DeleteFileFromTag(tagID=self.id,
                               fileID = file.id,
                     config = self._owner.config):
        return False

    # Remove the file from our list       
    self._removed(file)
    # Vice versa
    file._removed(self)
    
    return True
</t>
<t tx="ahab.20060403130903.87">
class File(RemoteProxy):
	&lt;&lt; class File declarations &gt;&gt;
	@others
</t>
<t tx="ahab.20060403130903.88">tags = None
partners = None

</t>
<t tx="ahab.20060403130903.89">def __init__(self, owner, refresh=True, **kwargs):
    """ Create a new File remote proxy. """

    self.tags = dict()
    self.partners = dict()
    self._remote = { "tag": (self.tags, Tag),
                     "Tag": "tag",
                     "user": (self.partners, Partner),
                     "Partner": "user" }

    RemoteProxy.__init__(self, owner, refresh, **kwargs)
</t>
<t tx="ahab.20060403130903.90">def refresh(self, timeout=10):
    """ Load the file information and open
    the file window temporarily. """

    fileinfo = Files.GetFile(fileID=self.id,
                            timeout=timeout,
                 config = self._owner.config)
                
    if not fileinfo:
        return False

    for attr in fileinfo:
        if attr not in ("tags", "files", "partners"):
            setattr(self, attr, fileinfo[attr])
    
    for attr in ('modified', 'created'):
        setattr(self, attr, time.strptime(fileinfo[attr], "%m/%d/%Y %H:%M:%S %p"))
        
    self._loaded = True

    return fileinfo
</t>
<t tx="ahab.20060403130903.91">def delete(self):
    """ Remove this file completely. """

    if not Files.DeleteFile(self.id,
          config=self._owner.config):
        return False

    # Notify any local tags
    for tag in self.tags:
        tag._removed(self)

    # Notify the user    
    self._owner._removed(self)
    
    # Make sure we don't try something stupid
    del self.id
    
    return True
</t>
<t tx="ahab.20060403130903.92">def getUrl(self):
    """ Retrieve the url for downloading this file. """

    if not self._loaded:
        if not self.refresh():
            return False

    params = { "fileToken": self.filetoken }

    return API.getUrl(params, baseurl=API.DOWNLOAD)
</t>
<t tx="ahab.20060403130903.93">def getData(self):
    """ Retrieve the contents of the file """

    url = self.getUrl()    
    if not url:
        return None
        
    f = urllib.urlopen(url)
    fileData = f.read()
    return fileData
</t>
<t tx="ahab.20060403130903.94">def download(self, filename):
    """ Write a local file with our contents. """
    
    fileData = self.getData()
    if fileData is None:
        return False
    
    # save the data
    here = file(filename, 'wb')
    here.write(fileData)
    here.close()
    
    # set the modification stamp
    mtime = calendar.timegm(self.modified)
    os.utime(filename, (mtime, mtime))
    return True
</t>
<t tx="ahab.20060403130903.95">def upload(self, filename, refresh=True):
    """ Upload a local file's contents over ours. """
    
    if not self.ModifyFile(fileID = self.id,
                        filename = filename,
                config = self._owner.config):
        return False

    # We're outta date.
    self._loaded = False
    
    if refresh:
        self.refresh()

    return True
</t>
<t tx="ahab.20060403130903.96"># 
# These next two simply delegate to the Tag class
# 



def addToTag(self, tag):
    """ Add this file to a tag. """
    if tag.id in self.tags:
        return True
    
    return tag.addFile(self)
</t>
<t tx="ahab.20060403130903.97">def removeFromTag(self, tag):
    """ Remove a tag from this file. """
    if tag.id not in self.tags:
        return False

    return tag.deleteFile(self)
</t>
<t tx="ahab.20060403130903.98"></t>
<t tx="ahab.20060403130903.99"></t>
<t tx="ahab.20060403130903.100">#!/usr/bin/python
"""  openomy-download.py - openomy-python example

This openomy python example downloads the contents
of your Openomy account to a local directory, skipping any
pre-existing files.

This is just an example.  For better synchronization, use
openomy-sync.py. """

import os, os.path
import openomy

# For debugging.
#import urllib
#proxies = {'http': 'http://localhost:8080/'}
#urllib._urlopener = urllib.FancyURLopener(proxies)

# ~/Openomy will be the destination.
destdir = os.path.join(os.path.expanduser("~"), "Openomy")
if not os.path.exists(destdir):
  os.makedirs(destdir)

# Get a local file list
files = os.listdir(destdir)


# The openomy.User object automatically 
# manages the user login, keys, and tokens.
# Settings will be automatically loaded from 
# and saved to "~/.openomy/openomy.ini"
# NOTE: YAML support requires PyYAML 3000 
# This will check openomy.yml.
# We don't want to load the tag list, just 
# download files.  So, no auto-refresh.
print "Logging in..."
u = openomy.User(refresh=False)

# Refresh and sort the remote file list

print "Retrieving remote file listing..."
rfiles = u.GetAllFiles()
for nfile in range(len(rfiles)):
  rfiles[nfile] = (rfiles[nfile].name, rfiles[nfile])
rfiles.sort()


print "Downloading to %s..." % destdir
for fname, ofile in rfiles:  
  if ofile.name not in files:
    print "Downloading %s..." % ofile.name
    filename = os.path.join(destdir, ofile.name)
    ofile.download(filename)
    print "\tdone."
  else:
    print "Skipping %s...already exists.\n" % ofile.name

print "All done!"

</t>
<t tx="ahab.20060403130903.102">#!/usr/bin/python
""" openomy-sync.py - Openomy Account and Tag synchronizer

    @summary      Facilitates synchronization between a
                  local directory and a remote Openomy
                  account or tag(s).
    @version      0.3 - Implemented login and registration capabilities
    @author       CptnAhab &lt;cptnahab@gmail.com&gt;
    @copyright    (C) 2006 CptnAhab
    @license      Free Software.  See LICENSE.txt for details.
    
"""

&lt;&lt; declarations &gt;&gt;

@others

if __name__ == "__main__":

    &lt;&lt; parse command line &gt;&gt;

    &lt;&lt; command execution &gt;&gt;
</t>
<t tx="ahab.20060403130903.103">import openomy
import os, os.path
import stat, time
import optparse # requires python2.3+

DIR_DOWN = -1
DIR_BOTH = 0
DIR_UP = 1

</t>
<t tx="ahab.20060403130903.104">class OpenomySync:
    """ A class responsible for synchronizing a folder
        with an openomy account or tag.
    
        @ivar direction:  Whether synchronization is to be
                          Up-only (DIR_UP), Down-only
                          (DIR_DOWN), or both
                          (DIR_BOTH).
        @ivar user:       The openomy.User object whose account
                          is to be sync'ed.
                        
    """
    
    @others</t>
<t tx="ahab.20060403130903.105">def __init__(self, direction=DIR_BOTH, username=None, password=None, email=None):
  """ Create an openomy synchronizer object. """
  self.direction = direction
    
  if username or password or email:
    self.user = openomy.User(auth=false, refresh=false)
    if username:
        self.user.config['username'] = username
    if password:
        self.user.config['password'] = password
    if email:
        self.user.config['email'] = email
    
    if self.user.obtainAccess():
        self.user.refresh()
    
  else:
    self.user = openomy.User()
    
  if self.user.authLevel != 7:
    raise "Could not authorize access."
</t>
<t tx="ahab.20060403130903.106">def getRemoteFileList(self, tag=None):
  """ Retrieve a list of remote file tuples (id, obj)
  from either a tag or the whole account. """

  filesrc = self.user
  if tag:
    if hasattr(tag, 'files'):
      filesrc = tag
    else:
      # we'll assume it's a string with a tagname.
      filesrc = self.user.tags[tag]

  filesrc.refresh()

  # Retrieve the actual list of files
  rfiles = dict()
  for key in filesrc.files:
    rfile = filesrc.files[key]
    if rfile.name not in rfiles:
        rfiles[rfile.name] = rfile
  rfiles = rfiles.items()
  rfiles.sort()

      
  # print "Files: %s" % str(rfiles)
    

  return rfiles
</t>
<t tx="ahab.20060403130903.107">def upload(self, filename, tag=None, exists=False):
  """ Add a local file to the Openomy user account. """
  
  if self.direction &gt; DIR_DOWN:
    # ok to upload
    if not exists:
      self.user.addFile(filename, tag=tag)
    else:
      file = self.user.files[os.path.basename(filename)]
      file.upload(filename, False)
    return True
  return False
</t>
<t tx="ahab.20060403130903.108">def download(self, rfile, filename):
  """ Download the openomy.File file data
  into the local file specified by filename. """
  
  if self.direction &lt; DIR_UP:
    # ok to download
    rfile.download(filename)
    # set the timestamp!!!!
    if not rfile._loaded:
      rfile.refresh()
      rModTime = calendar.timegm(rFile.modified)
      os.utime(filename, (rModTime, rModTime)) 
    return True
  return False
</t>
<t tx="ahab.20060403130903.109">def sync(self, directory, tag=None, verbose=True):
  """ Synchronize a local folder with a
  remote tag or personal file list. """
    
  # Make sure we have a tag object
  if tag and not hasattr(tag, 'id'):
    if tag not in self.user.tags:
        # Create the tag automagically
        self.user.createTag(tag)
    tag = self.user.tags[tag]

  # Get the remote list
  lRemote = self.getRemoteFileList(tag)

  # Get the local list
  lLocal = os.listdir(directory)
  lLocal.sort()

  # Walk the list and find missing items
  MARKER = "\xFF"
  nUp, nDown, nLocal, nRemote = 0, 0, 0, 0
  while (nLocal &lt;= len(lLocal) and nRemote &lt;= len(lRemote)) and not \
        (nLocal &gt;= len(lLocal) and nRemote &gt;= len(lRemote)):
    
    if nLocal &gt;= len(lLocal):
      strLocal = MARKER
    else:
      strLocal = lLocal[nLocal]
    
    if nRemote &gt;= len(lRemote):
      strRemote = MARKER
    else:
      strRemote = lRemote[nRemote][0]


    if strLocal &lt; strRemote:
      # strLocal is not on remote
      filename = os.path.join(directory, strLocal)
      if not os.path.isfile(filename):
        print "\t\tSkipping subfolder %s" % filename
      else:
        # upload it
        if verbose:
          print "\t\tUploading %s" % strLocal
        if self.upload(filename, tag):
          nUp += 1
      # check the next local file
      nLocal += 1

    elif strRemote &lt; strLocal:
      # strRemote is not on local
      if verbose:
        print "\t\tDownloading %s" % strRemote
      
      filename = os.path.join(directory, strRemote)
      if self.download(lRemote[nRemote][1], filename):
        nDown += 1

      # check the next remote file
      nRemote += 1

    else:
      # They're the same filename.  Which one is newer?
      # TODO: cache the most recent modified stamp for
      # each remote file. (ick)
      filename = os.path.join(directory, strLocal)
      if not os.path.isfile(filename):
        print "\t\tSkipping subfolder %s" % filename
      else:
        lFile = os.stat(filename)
        lSize =lFile[stat.ST_SIZE]
        lModStamp = time.localtime(lFile[stat.ST_MTIME])

        rFile = lRemote[nRemote][1]
        rFile.refresh()
        rSize = int(rFile.size)
        rModStamp = rFile.modified
        
        # File size is irrelevant, but helpful for
        # debugging the timestamps.
        if lSize != rSize:
          if lModStamp &gt; rModStamp:
            # Local file is newer.  Upload.
            if verbose:
              print "\t\tUploading %s" % strLocal
            if self.upload(filename, tag, exists=True):
              nUp += 1
          else:
            # Remote file is newer.  Download.
            if verbose:
              print "\t\tDownloading %s" % strLocal
            if self.download(rFile, filename):
              nDown += 1
        else:
          print "\t\tSkipping %s" % strLocal

      nLocal += 1
      nRemote += 1

  return nUp, nDown
</t>
<t tx="ahab.20060403130903.130">#!/usr/bin/python
""" openomy_update.py - Updater for the python openomy tools.
    @version    0.2
    @summary    This updater automatically downloads the latest 
                version of the openomy tools from the openomy-python.
                googlecode.com/svn/trunk.
    @author       CptnAhab &lt;cptnahab@gmail.com&gt;
    @copyright    (C) 2006-2007 CptnAhab
    @license      Free Software.  See LICENSE.txt for details.
    
"""

&lt;&lt;imports&gt;&gt;


# Retrieve the local file listing
curpath = os.getcwd()
curfiles = os.listdir(curpath)

# Retrieve the remote file listing
print "Downloading file list...",
# TODO: Create a stable tag/branch (?)
trunkUrl = "http://openomy-python.googlecode.com/svn/trunk/"
fRSS = urllib.urlopen(trunkUrl)
strRSS = fRSS.read()
fRSS.close()
print "done."

# Extract the remote filelist from the svn filelist
down = 0
reFiles = re.compile("&lt;li&gt;&lt;a href=\"[^\"]+\"&gt;([^&lt;]+)&lt;/a&gt;&lt;/li&gt;", re.S)
matches = reFiles.findall(strRSS)

# Download each file in the feed
for fname in matches:
    # convert to a struct_time
    if fname == '..': continue
    
    filename = os.path.join(curpath, fname)
    if fname not in curfiles or os.path.isfile(filename):
        print "Downloading %s..." % filename,
        link = trunkUrl + fname
        uret = urllib.urlretrieve(link, filename)
        print "done."
        down += 1
    else:
        print "Cannot overwrite directories or symlinks - %s" % filename

print "Update complete.  Downloaded %i files." % down

</t>
<t tx="ahab.20060403131358">@language python
@path /home/adam/Desktop/openomy-python
</t>
<t tx="ahab.20060403131721"></t>
<t tx="ahab.20060403131903">
def DebugMethod(method):

    def decorated(self, *args, **kwargs):
        print "Calling %s..." % method.__name__
        # print the arguments
        print "...Arguments: %s" % str(args)
        print "...Keywords: %s" % str(kwargs)
        # print the kwargs
        
        try:
            ret = method(self, *args, **kwargs)
        except Exception, e: 
            # print the exeption and reraise
            print '%s (%s)' % (e.__class__, e)
            raise
        
        # print the return value
        print "...Returned %s" % str(ret)
        return ret
    
    return decorated

</t>
<t tx="ahab.20060403132104">=== Layer 0: API, Configuration, DefaultConfiguration ===

The innermost layer consists of two complementary types of objects: the [[openomy.py/API|API]], and the [[openomy.py/Configuration|Configuration]].  While the API manages the process of the communication, the Configuration handles user settings, app keys, and tokens. To simplify the implementation of applications which use this library, a [[openomy.py/DefaultConfiguration|DefaultConfiguration]] class has also been created allowing for the distribution of default settings.

</t>
<t tx="ahab.20060403132124"></t>
<t tx="ahab.20060403132124.1"></t>
<t tx="ahab.20060403132406">
# For debugging.
#import urllib2
#proxies = {'http': 'http://localhost:8888/'}
#proxy_handler = urllib2.ProxyHandler(proxies)
#opener = urllib2.build_opener(proxy_handler)
#urllib2.install_opener(opener)


# args should be a list of directories to synchronize
# with their eponymous tags, or empty to synchronize the current
# directory with your personal root file store.
print "Logging in to Openomy..."
s = OpenomySync(options.direction, options.user,
                options.passwd, options.email)

# Normalize the optional base sync directory
basedir = os.path.abspath(os.path.normpath(options.base or ""))

if len(args) == 0:
  # synchronize file store
  print "Synchronizing account to %s..." % basedir
  up, down = s.sync(basedir, options.tag)
  print "Synchronization complete. Files: Up %i  Down %i" % (up, down)

else:
  # synchronize a list of tags
  ttlup, ttldown = 0, 0
  print "Synchronizing specified tags to %s..." % basedir
  for arg in args:
    dirname = os.path.join(basedir, arg)
    if not os.path.exists(dirname):
      os.makedirs(dirname)
    if not os.path.isdir(dirname):
      print "%s is not a folder."
      continue

    print "\tSynchronizing tag %s..." % arg
    up, down = s.sync(dirname, arg)
    print "\tTag synchronization complete. Files: Up %i  Down %i" % (up, down)
    ttlup += up ;  ttldown += down
  print "Synchronization complete. Files: Up %i  Down %i" % (ttlup, ttldown)</t>
<t tx="ahab.20060403132446"># Construct the command line argument handling
oparser = optparse.OptionParser()

# These options are only to get the confirmed token
# i.e. first run only.
oparser.add_option("-a", "--acct", dest="user",
                    help="authenticate with account USER", metavar="USER")
oparser.add_option("-p", "--pass", dest="passwd",
                    help="authenticate with password PASS", metavar="PASS")
oparser.add_option("-e", "--email", dest="email",
                    help="register new user with email EMAIL", metavar="EMAIL")
                    
# This option allows you to synchronize the current folder
# with a specific single tag
oparser.add_option("-t", "--tag", dest="tag",
                    help="synchronize with TAG", metavar="TAG")

# This option allows you to specify the base folder to use
# if not the current folder
oparser.add_option("-b", "--base", dest="base",
                    help="set base directory for synchronization to BASE", metavar="BASE")


# These options allow you to synchronize in only one direction
oparser.add_option("-d", "--download", dest="direction", action="store_const",
                    help="download only; do not upload anything.", const=DIR_DOWN)
oparser.add_option("-u", "--upload", dest="direction", action="store_const",
                    help="upload only; do not download anything.", const=DIR_UP)
oparser.set_default('direction', DIR_BOTH)

# TODO: Options for excluding or including certain files
#       Let's look at tar, cpio, etc.

# Parse the command line
(options, args) = oparser.parse_args()
</t>
<t tx="ahab.20060403143905">#!/usr/bin/python

@others


if __name__ == '__main__':

	server = OpenomyFS();
	server.multithreaded = 1;
	server.main();
</t>
<t tx="ahab.20060403143905.1">
import os
from errno import *
from stat import *

from fuse import Fuse

import openomy

import re

</t>
<t tx="ahab.20060403143905.2">
class OpenomyFS(Fuse):

	@others

</t>
<t tx="ahab.20060403143905.3">
def __init__(self, *args, **kw):
        """ Create a new Openomy FS FUSE point. """

        Fuse.__init__(self, *args, **kw)

        self.user = openomy.User()

        self.user.refreshAllTags()
        self.user.refreshAllFiles()
        
        self.rePath = re.compile("(?:/tags/(?P&lt;tagname&gt;[^/]+)(?:/(?P&lt;tagfile&gt;[^/]+))?)|(/(?P&lt;filename&gt;[^/]*))")


def _splitpath(self, path):
    # Return a dictionary of path details
    pinfo = {
        "tagname": None,
        "tagfile": None,
        "filename": None
        }
    
    match = self.rePath.match(path)
    if match:
        for key in pinfo:
            pinfo[key] = (match.group(key) and 
                                    match.group(key).strip()
                                    ) or None
                
    return pinfo["tagname"], pinfo["tagfile"], pinfo["filename"]
</t>
<t tx="ahab.20060403143905.4"># getattr: called to check for the existence and attributes of a file or a directory,
#               even before many other operations
def getattr(self, path):

        tagname, tagfile, filename = self._splitpath(path)

        # The only two directories: say that they are directories
        if filename == "tags" or (tagname is tagfile is filename is None):
                return (S_IFDIR | 0755, 0, 0, 2, 0, 0, 0, 0, 0, 0)

        # Check for a tag
        elif tagname and tagname in self.user.tags:
            if not tagfile:
                return (S_IFDIR | 0755, 0, 0, 2, 0, 0, 0, 0, 0, 0)
                
            # Check for a file within a tag
            tag = self.user.tags[tagname]
            if tagfile in tag.files:
                file = tag.files[tagfile]
                if not hasattr(file, 'size'): file.refresh()
                return (S_IFREG | 0777, 0, 0, 1, 0, 0, int(file.size), 0, 0, 0)
                
            #else:
            #    return None

        # Check for a regular non-directory path
        elif filename:
            if filename in self.user.files:
                file = self.user.files[filename]
                if not hasattr(file, 'size'): file.refresh()
                return (S_IFREG | 0777, 0, 0, 1, 0, 0, int(file.size), 0, 0, 0)
                
            #else:
            #    return None
           
        e = OSError("No such file "+path)
        e.errno = ENOENT
        raise e
</t>
<t tx="ahab.20060403143905.5"># Returns the contents of a directory
def getdir(self, path):
        dirlist = ['.', '..']

        tagname, tagfile, filename = self._splitpath(path)

        if (path == "/"):
                dirlist.append('tags')
                for file in self.user.links("file"):
                        dirlist.append(file.name)

        elif (path == "/tags"):
                for tag in self.user.links("tag"):
                        #print "Tag: %s" % str(tag.__dict__)
                        dirlist.append(tag.name)

        # A tag
        elif (path.startswith("/tags")):
                tagname = path[6:]
                #print "Tag:", tagname;
                if tagname in self.user.tags:
                        tag = self.user.tags[tagname]
                        for file in tag.links("file"):
                                dirlist.append(file.name)
                else:
                        return -ENOENT

        return map(lambda x: (x,0), dirlist)

</t>
<t tx="ahab.20060403143905.6">def rmdir(self, path):
    tagname, tagfile, filename = self._splitpath(path)
    if not tagname:
        return -EPERM
        
    if tagname in self.user.tags:
            self.user.tags[tagname].delete()
            return 0

    return -ENOENT

</t>
<t tx="ahab.20060403143905.7">def mkdir(self, path, mode):
    tagname, tagfile, filename = self._splitpath(path)
    
    if not tagname or tagfile or filename:
        return -EPERM

    if tagname not in self.user.tags:
        self.user.createTag(tagname)
    
    return 0
    

</t>
<t tx="ahab.20060403143905.8">def open(self, path, flags):
    filename = os.path.basename(path)
    if filename not in self.user.files:
            return -ENOENT

    file = self.user.files[filename]
    return 0;


</t>
<t tx="ahab.20060403143905.9">def read(self, path, length, offset):
    filename = os.path.basename(path)
    if filename not in self.user.files:
            return -ENOENT;

    file = self.user.files[filename]
    filedata = file.getData()
    
    if (length &gt; file.size): length = file.size

    return filedata[offset:offset+length]

</t>
<t tx="ahab.20060403143905.10">def write(self, path, buf, off):
    if (path.startswith("/tags/")):
            return len(buf);
    
    # This isn't really correct.
    filename = os.path.basename(path)
    file = self.user.files[filename]
    size = getattr(file, 'size', None)
    if size == 0:
        filedata = ""
    else:
        filedata = file.getData()

    filedata = ''.join([
            filedata[:off], buf, 
            filedata[off+len(buf):] ])
    
    params = { "method": "Files.ModifyFile",
               "fileID": file.id }
    upload_files = [('fileField', filename, filedata)]
    if not openomy.API.dispatch(params, files=upload_files,
                                config=self.user.config):
        return 0
    
    return len(buf);

</t>
<t tx="ahab.20060403143905.11">def truncate(self, path, size):
    tagname, tagfile, filename = self._splitpath(path)
    
    if (filename and filename not in self.user.files):
        return -1

    if tagfile:
        return 0
        
    # Regular file
    file = self.user.files[filename]
    file.size = size

    return 0


</t>
<t tx="ahab.20060403143905.12">def release(self, path, flags):
    return 0

</t>
<t tx="ahab.20060403143905.13"># Remove a file
def unlink(self, path):
    
    tagname, tagfile, filename = self._splitpath(path)
    
    if filename and filename not in self.user.files:
        return -ENOENT
    elif tagname and (tagname not in self.user.tags
            or not tagfile or tagfile not in self.user.files):
        return -ENOENT
    
    
    # Removing a file from a tag
    if tagfile:
        tag = self.user.tags[tagname]
        if tagfile not in tag.files:
                return -ENOENT;
    
        file = tag.files[tagfile]
        file.removeFromTag(tag)
    
    # Removing a regular file
    elif filename:
        self.user.files[filename].delete()
    
    return 0

</t>
<t tx="ahab.20060403145026"># Url opener
import urllib

# Remote file timestamps
import time

# Regular expression matching
import re

# Path manipulation and directory listing
import os, os.path

# Local file timestamps
import stat</t>
<t tx="ahab.20060403162622">The DefaultConfiguration class is a namespace (with a getter and setter) for providing defaults for the Authentication process, as well as for user preferences.  User specified settings (not defaults) are handled by a [[openomy.py/Configuration|Configuration]] instance.



</t>
<t tx="ahab.20060403162724">The Configuration class is responsible for handling all aspects of the interaction with an OS-level user's preferences, settings, tokens, and keys.  This facilitates multiple users on the same host using a single copy of the openomy library, as well as ensuring no end-user code maintenance is required.

</t>
<t tx="ahab.20060403162724.1">The API class handles the process of request construction, communication and response analysis.  All of API's methods and members are static, so you needn't instantiate it.

The method call process involves the following steps: [[#Setting_Parameters|setting method call parameters]]; [[#Authorization|applying keys, tokens, and signatures]] to the request; [[#Dispatching_the_Request|dispatching the request]]; [[#Determining_Success_or_Error|determining the result status]]; and [[#Extracting_Data_from_the_Response|extracting returned objects and data]].


</t>
<t tx="ahab.20060405103414.1">This page describes the openomy-python bindings, ''openomy.py''.</t>
<t tx="ahab.20060405114844">This page describes the openomy python file synchronizer, ''openomy_sync.py''.

</t>
<t tx="ahab.20060405114844.1">This page describes the openomy python library updater, ''openomy_update.py''.

</t>
<t tx="ahab.20060407101004">
def __getattr__(self, name):
    """ Check for capwords/uscore notation """
    
    # Python attribute name trickery
    # automatically finds "getTag" when you 
    # use ob.GetTag or ob.get_tag
    if name[0] != name[0].lower():
        return getattr(self, name[0].lower() + name[1:])
    elif "_" in name:
        name = re.sub(r'_([a-z])', lambda m: (m.group(1).upper()), name)
        return getattr(self, name)
    else:
        raise AttributeError, name
</t>
<t tx="ahab.20060407103204">== Setting Parameters ==

The first step in making a remote Openomy method call is to collect the method name and parameters into a dictionary.  This allows the API to more easily manage the process of authorization and dispatch.  Individual method names and their parameters are documented [[Currently_Supported_Methods|here]].

    import openomy
    
    # We need to manually construct a
    # Configuration since we're using
    # the API object directly.
    c = openomy.Configuration(default=True)
    
    # Files.GetAllFiles has no optional
    # or required parameters; just set
    # the method name
    params = { "method": "Files.GetAllFiles" }
    
    response = openomy.API.dispatch(params)
    if not response:
        raise "GetAllFiles failed!"</t>
<t tx="ahab.20060407103204.1">== Authorization ==

After setting call parameters, the next step is to authorize the remote call. In order to authorize remote method requests, Openomy may require one or more of the following to be attached: an [[Application_Key|application key]], an [[Unconfirmed_Token|unconfirmed token]], a [[Confirmed_Token|confirmed token]], and/or a signature.  (For more details, see [[How_Web_Apps_Work]].) 

If you are invoking the [http://cptnahab.googlepages.com/openomy.API-class.html#dispatch dispatch()] method, the appropriate key, token, and signature will be applied automatically (see below).  If you are submitting your own GET/POST requests directly without dispatch(), you can have a list of method parameters keyed and signed by calling the [http://cptnahab.googlepages.com/openomy.API-class.html#dispatch sign()] method:

*; API.sign(params, config=None, cfm=True)
*: Apply keys (and tokens if ''cfm'' is True), and return a signature string, optionally using keys and tokens from ''config''.

The keys and tokens for the signature will be taken from either a [[openomy.py/Configuration|Configuration]] object passed in the ''config'' parameter, from the default Configuration object (i.e. one instantiated with it's default parameter set to True), or if those are not available, from the [[openomy.py/DefaultConfiguration|DefaultConfiguration]] class.  Currently, the application key and private key ''must come from the same'' of these three sources.

    import openomy, urllib
    
    c = openomy.Configuration()
    
    params = {"method": "Files.GetAllFiles"}
    
    # Files.GetAllFiles requires a confirmedToken,
    # so we pass True in cfm.
    sig = API.sign(params, config=c, cfm=True)
    if cfm and not sig:
        raise "Signing failure."
        
    print "Full url: %s?%s" % (API.REST, urllib.urlencode(params))


</t>
<t tx="ahab.20060407103204.2">== Dispatching the Request ==

After applying any necessary keys, tokens and signatures, the next (and most important) step in calling a remote method is to actually dispatch the request.

The API class has a  [http://cptnahab.googlepages.com/openomy.API-class.html#dispatch method] to automatically submit a request from a mapping of parameters:

*; API.dispatch(params, baseurl=REST, files=None, config=None, cfm=True)
*: Dispatch a request and return the successful response text, optionally using keys and tokens from ''config''.  Returns False on failure.


A dispatch is shown in this example:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    c = openomy.Configuration()
    params = {"method": "Files.GetAllFiles"}
    
    # Since the Configuration object was the default,
    # Therefore it saved itself onto the API object,
    # Therefore no need to pass 'c' to dispatch.
    response = openomy.API.dispatch(params)
    if not response:
        raise "Files.GetAllFiles failed."
&lt;/pre&gt;&lt;/blockquote&gt;


If you decide not to use the dispatch method, but instead choose to perform your own network operations, you can still use the [http://cptnahab.googlepages.com/openomy.API-class.html#getUrl getUrl()] and [http://cptnahab.googlepages.com/openomy.API-class.html#getUrl getRequest()] methods to build the HTTP message for GET and POST submissions, respectively:

*; API.getRequest(params, url, files, config=None, cfm=True)
*: Build a urllib2 Request object with call parameters ''params'', at ''url'', optionally using keys (and confirmed token if ''cfm'') from ''config''.

*; API.getUrl(params, baseurl, config=None, cfm=True)
*: Build a complete request url with call parameters ''params'', at ''baseurl'', optionally using keys (and confirmed token if ''cfm'') from ''config''.


This example demonstrates a simple GET ([[REST|REST-like]]) request:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy, urllib
    c = openomy.Configuration()
    
    params = {"method": "Files.GetAllFiles"}
    url = openomy.API.getUrl(params)
    f = urllib.urlopen(url)
    response = f.read()
    
    if not openomy.API.succeeded(response):
        raise "Files.GetAllFiles failed."
&lt;/pre&gt;&lt;/blockquote&gt;

</t>
<t tx="ahab.20060407103204.3">== Determining Success or Error ==

After dispatching the request, you should next confirm the success or failure of the remote method call.

If you used the dispatch() method, it will return false upon failure.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    c = openomy.Configuration()
    
    params = {"method": "Files.GetAllFiles"}
    
    # Send and recieve
    response = openomy.API.dispatch(params)
    
    # Check the response for truth (False is failure)
    if not response:
        raise Exception, "Files.GetAllFiles failed."
&lt;/pre&gt;&lt;/blockquote&gt;


If you did not use dispatch(), you can call [http://cptnahab.googlepages.com/openomy.API-class.html#succeeded succeeded()] to see if the xml contains a successful response:

*; API.succeeded(response)
*: Checks for a ''&lt;success&gt;'' tag in response.  Returns True if found; False otherwise.

''TODO: In version 0.5, throw an [[APIError]] exception containing the Openomy Error code.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy, urllib
    c = openomy.Configuration()
    
    params = {"method": "Files.GetAllFiles"}
    url = openomy.API.getUrl(params, config=c)
    f = urllib.urlopen(url)
    response = f.read()
    
    if not openomy.API.succeeded(response):
        raise Exception, "Files.GetAllFiles failed."
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060407103204.4">== Extracting Data from the Response ==

Four seperate classmethods are available for extracting data from response XML strings. 

[http://cptnahab.googlepages.com/openomy.API-class.html#extract API.extract()] provides string search similar to the built-in string.find() function:

*; API.extract(haystack, beforeneedle, afterneedle)
*: Extract a needle from the string ''haystack'' based on the surrounding context, ''beforeneedle'' and ''afterneedle''.  Returns only the first occurrence found.


&lt;blockquote&gt;&lt;pre&gt;    
    import openomy    
    
    c = openomy.Configuration()
    
    params = { "method": "Auth.GetUnconfirmedToken" }
    response = openomy.API.dispatch(params, cfm=False)
    if not response:
        raise "Auth.GetUnconfirmedToken call failed!"
    
    print API.extract(response, "&lt;unconfirmedtoken&gt;", 
                                "&lt;/unconfirmedtoken&gt;")
&lt;/pre&gt;&lt;/blockquote&gt;


[http://cptnahab.googlepages.com/openomy.API-class.html#extractObjects API.extractObjects()] is used to identify the object types, ids, and names referred to in a response:

*; API.extractObjects(response, tagname=None):
*: Return a list of (tagname, id and name) tuples for objects with xml tags ''&lt;tagname&gt;'' in the string ''response''.


&lt;blockquote&gt;

An example taken from [[openomy.py/Tags|Tags.GetTag]]:

&lt;pre&gt;
    import openomy    
    
    c = openomy.Configuration()
    tagID = 1
    params = { "method": "Tags.GetTag",
               "tagID": tagID }

    response = openomy.API.dispatch(params)
    if not response:
        return False

    tag_files = API.extractObjects(response, "file")
    for (otype, fileid, filename) in tag_files.items():
        assert(otype == "file")
        print "File %s: %s" % (fileid, filename)
&lt;/pre&gt;&lt;/blockquote&gt;


[http://cptnahab.googlepages.com/openomy.API-class.html#extractFields API.extractFields()] parses the response for any xml fields whatsoever:

*; API.extractFields(response):
*: Return a mapping of tagname to tag content from response's XML.


&lt;blockquote&gt;

An example using [[openomy.py/Files|Files.GetFile]]:

&lt;pre&gt;
    import openomy    
    
    c = openomy.Configuration()
    fileID = "12345"
    params = { "method": "Files.GetFile",
               "fileID": fileID }
               
    response = openomy.API.dispatch(params)
    if not response:
        raise "Files.GetFile call failed!"
    
    fileinfo = openomy.API.extractFields(response)
    
    print "File details for %s:" % fileID
    for (key, val) in fileinfo.items():
        print "\t%s: %s" % (key, val)
&lt;/pre&gt;&lt;/blockquote&gt;


[http://cptnahab.googlepages.com/openomy.API-class.html#extractId API.extractId()] can be used to extract a single object id from a response:

*; API.extractId(response, tagname=None):
*: Return a list of (tagname, id and name) tuples for objects with xml tags ''&lt;tagname&gt;'' in the string ''response''.


&lt;blockquote&gt;

An example using [[openomy.py/Tags|Tags.CreateTag]]:

&lt;pre&gt;
    import openomy    
    
    c = openomy.Configuration()
    
    params = { "method": "Tags.CreateTag",
               "tagName": "MyNewestTag" }
    response = openomy.API.dispatch(params)
    if not response:
        raise "Tags.CreateTag call failed!"
    
    print "Created tag %s" % API.extractId(response, "tag id")
&lt;/pre&gt;&lt;/blockquote&gt;


</t>
<t tx="ahab.20060407103327">=== Layer 1: Auth, Files, Tags ===

The middle layer implements static classes (micro-modules) of the familiar Openomy interfaces, [[openomy.py/Auth|Auth]], [[openomy.py/Files|Files]], and [[openomy.py/Tags|Tags]].  These objects use the functionality provided by Layer 0 to create an interface to the individual [[Currently_Supported_Methods|Openomy REST calls]].

</t>
<t tx="ahab.20060407103327.1">=== Layer 2: User, File, Tag, Partner (and RemoteProxy) ===

The outermost layer implements an object-oriented mesh, proxying calls for an individual [[openomy.py/User|User]], a [[openomy.py/File|File]], or a [[openomy.py/Tag|Tag]].  The [[openomy.py/Partner|Partner]] class handles representation of users other than the primary (authenticated) one.  These object classes rely on the [[openomy.py/RemoteProxy|RemoteProxy]] base class for maintaining data consistency, which in turn relies on the Layer 1 classes for its remote agency.


</t>
<t tx="ahab.20060407103347"></t>
<t tx="ahab.20060407103634">== Overriding the Defaults ==
The DefaultConfiguration is distributed with the application settings for the openomy-python bindings (as you might expect).  There are several potential ways to specify a different default configuration in your own program, depending on your specific needs:


* Directly modify the DefaultConfiguration class through it's set() method: 

&lt;blockquote&gt;&lt;pre&gt;
    import openomy

    config = openomy.DefaultConfiguration
    config.set("name", "My Openomy Application")
    config.set("version", "0.1")
&lt;/pre&gt;&lt;/blockquote&gt;

* Subclass DefaultConfiguration, and assign the new class to API.config:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy

    class MyOpenomyAppConfig(openomy.DefaultConfiguration):
        applicationKey = "00000000000000000000000000"
        privateKey = "00000000"

    openomy.API.config = MyOpenomyAppConfig
&lt;/pre&gt;&lt;/blockquote&gt;

* Provide an object to API with the necessary get() and set() methods:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    
    openomy.API.config = {
          applicationKey = "00000000000000000000000000",
              privateKey = "00000000",
          confirmedToken = "0000000000000000000000000000000000"
                         }
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060407103634.1">=== Instantiation ===

If your application is using the Layer 0 [[openomy.py/API|API]] class or any Layer 1 class ([[openomy.py/Auth|Auth]], [[openomy.py/Files|Files]], [[openomy.py/Tags|Tags]]), you will need to instantiate a Configuration object yourself:

*; __init__(path=None, name=None, default=False)
*: Create a new configuration with filesystem location ''path''/''name''.  If ''default'' is True, it will become the global default Configuration object.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    # Set the default configuration file source
    # to "/etc/appname/myapp.XXX", and make it
    # the default configuration of openomy.API
    config = openomy.Configuration(path="/etc/appname/",
                                   name="myapp",
                                   default=True)
    
    # Attempt to load both myapp.yml and myapp.ini
    config.load(format=config.FORMAT_ANY)
    # Define our request parameters
    params = { "method": "Files.GetFile",
               "fileID": "12345",
               "timeout": "10" }
    
    # Dispatch a request to openomy
    response = openomy.API.dispatch(params, config=config)
    if not response:
        raise "Failure!"
    # Collect the attributes from the juice GetFile response
    fileinfo = openomy.API.extractFields(response)
    for item in fileinfo.items():
        print "%s: %s" % item
&lt;/pre&gt;&lt;/blockquote&gt;


If your application is using the Layer 2 classes ([[openomy.py/User|User]], [[openomy.py/File|File]], [[openomy.py/Tag|Tag]] and [[openomy.py/Partner|Partner]]), the Configuration class is typically managed automatically by the User object.  Under certain circumstances, you may wish to override the default Configuration loading mechanism:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    # Set the default configuration file source
    # to "/etc/appname/myapp.XXX", and make it
    # the default configuration of openomy.API
    config = openomy.Configuration(path="/etc/appname/",
                                   name="myapp",
                                   default=True)
    
    # Attempt to load both myapp.yml and myapp.ini
    config.load(format=config.FORMAT_ANY)
    # When instantiating a User object with a
    # non-default configuration, you should
    # skip both auto-config-loading and
    # auto-authenticating.
    user = openomy.User(config=False,
                        auth=False)
    
    # Store the configuration on the user
    user.config = config
&lt;/pre&gt;&lt;/blockquote&gt;



</t>
<t tx="ahab.20060407103634.2">=== Getting and Setting Parameters ===

The Configuration class has two default classmethods: get() and set().  These are basically identical to the mapping functions of the same name, and allow you to manipulate the configuration data in-memory:

*; get(attr)
*: Retrieve the configuration setting ''attr''.

*; set(attr, val)
*: Set the configuration setting ''attr'' to ''val''.


&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    
    config = openomy.Configuration()
    
    # Load config file(s) from disk
    config.load()
    # Check the user's config
    appName = config.get("name")
    
    if appName == "openomy-python":
        # Store some new values
        config.set("name", "My Openomy Application")
        config.set("version", "0.1")
        config.set("description", "A short textual description.")
        # Save back to disk
        config.save()
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060407103634.3">=== Loading and Saving ===

Two methods are provided for storage and retreival of a user's configuration from disk:

*; load(path=None, name=None, format=FORMAT_ANY)
*: Load the configuration file identified by local path ''path'' and filename ''name'', in format ''format''.  Returns True on success, False otherwise.

*; save(path=None, name=None, format=FORMAT_DEF)
*: Save the configuration data to the file ''path''/''file'' in format ''format''.


The optional paramater ''format'' can have one of the following values:

*; FORMAT_DEF
*: Default format.  Pass this to ''save''() if you don't know what format it was loaded in and what formats your Python environment supports.

*; FORMAT_ANY
*: Any format.  Pass this to ''load''() to read whatever format is available on disk.  Causes a check for either ".ini" or ".yml" extensions on ''name'' on disk.

*; FORMAT_YAML
*: .YML ([http://www.pyyaml.org/wiki/PyYAML PyYAML]/YAML) format.

*; FORMAT_INI
*: .INI ([http://docs.python.org/lib/module-ConfigParser.html ConfigParser]/Windows INI) format.


The ''load''() and ''save''() methods can be overridden to add new configuration formats or locations or whatever.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    
    config = openomy.Configuration()
    
    # Load config file(s) from disk
    config.load()
    # Save back to disk somwhere else
    config.save(path="~/Desktop/openomy",
                format=config.FORMAT_INI)
&lt;/pre&gt;&lt;/blockquote&gt;    
</t>
<t tx="ahab.20060423133517">
def AuthorizeUser(self, username=None, 
                            password=None,
                            config=None):
    """ Obtain a confirmed token for the user. """

    # Check the various levels of config
    if not username:
        username = API.getConfigParam('username', config)
    if not password:
        password = API.getConfigParam('password', config)

    params = { "method": "Auth.AuthorizeUser",
               "username": username,
               "password": password }

    response = API.dispatch(params, cfm=False, config=config)
    if not response:
        return False

    return API.extract(response, "&lt;confirmedtoken&gt;", 
                             "&lt;/confirmedtoken&gt;")


</t>
<t tx="ahab.20060423134114">
def RegisterUser(self, username=None, 
                            password=None, 
                            email=None,
                            config=None):
    """ Register a new user account on Openomy. """

    # Check the various levels of config
    if not username:
        username = API.getConfigParam('username', config)
    if not password:
        password = API.getConfigParam('password', config)
    if not email:
        email = API.getConfigParam('email', config)

    params = { "method": "Auth.RegisterUser",
               "username": username,
               "password": password,
               "email": email }

    response = API.dispatch(params, cfm=False, config=config)
    if not response:
        return False

    return API.extract(response, "&lt;confirmedtoken&gt;", 
                             "&lt;/confirmedtoken&gt;")


</t>
<t tx="ahab.20060423233314">This page provides a starting point for the openomy-python bindings and related tools (the library).


</t>
<t tx="ahab.20060423233314.1">@path /home/adam/lib/python2.4/site-packages</t>
<t tx="ahab.20060423233314.2"># ///////////////////////////////////
# Publish an entire wiki page.
from leoWiki import *

wikipos, wikiname, wikibase = wiki(p)
wikibody = wikiBody(wikipos)

g.es("Wiki Base: %s" % wikibase, color="blue")
g.es("  publishing %s..." % wikiname, color="purple")

resultpage = wikiSave(wikibase, wikiname, wikibody,
        editsummary='Publish', 
        editminor=False)

g.es("Finished.", color="blue")</t>
<t tx="ahab.20060423234132"># http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/146306
def wikiForm(fields):
    """
    fields is a sequence of (name, value) elements for regular form fields.
    files is a sequence of (name, filename, value) elements for data to be uploaded as files
    Return (content_type, body) ready for sending
    """
    BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'
    CRLF = '\r\n'
    L = []
    for (key, value) in fields:
        L.append('--' + BOUNDARY)
        L.append('Content-Disposition: form-data; name="%s"' % key)
        L.append('')
        L.append(value)
    L.append('--' + BOUNDARY + '--')
    L.append('')
    body = CRLF.join(L)
    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY
    return content_type, body
</t>
<t tx="ahab.20060423235240">== EpyDoc Reference ==

A complete specification of API class methods and members is available [http://cptnahab.googlepages.com/openomy.Configuration-class.html here].


</t>
<t tx="ahab.20060423235240.1">== Related Classes ==

See also:
* [[openomy.py/DefaultConfiguration|DefaultConfiguration]]
* [[openomy.py/Configuration|Configuration]]
</t>
<t tx="ahab.20060423235848"># ///////////////////////////////////
# Apply the headString as a heading
# in the body, with the correct 
# outline level ('=== ... ===')

from leoWiki import *

here = p.copy()
sectname = p.headString()
level = 1
wikiname = sectname
while not wikiname.startswith("@wiki "):
    p = p.parent()
    if not p:
        raise "Cannot find wiki page."
    wikiname = p.headString()
    level += 1
    
if level == 1:
    raise "Cannot set page title header"

headmark = "=" * level
header = " ".join([headmark, sectname, headmark])
l = here.bodyString().splitlines()
if len(l) and len(l[0]) and l[0][0]=="=":
    l = [header] + l[1:]
else:
    l = [header, ""] + l
here.setBodyString("\n".join(l))

g.es("Set header.")
    

</t>
<t tx="ahab.20060424001429">== EpyDoc Reference ==

A complete specification of class methods and members is available [http://cptnahab.googlepages.com/openomy.Configuration-class.html here].


</t>
<t tx="ahab.20060424001429.1">== Related Classes ==

See also:
* [[Openomy.py/DefaultConfiguration|DefaultConfiguration]]
* [[openomy.py/API|API]]
* [[openomy.py/User|User]]</t>
<t tx="ahab.20060424002321">== Overview ==

The openomy-python tools support end users in managing their Openomy applications, users, tags, and files.


</t>
<t tx="ahab.20060424002321.1">== Version History ==

; v0.3 - 2006-05-20
: Modified by CptnAhab
:* Added Auth.AuthorizeUser and Auth.RegisterUser
:* Changed most string matching to regEx

; v0.2 - 2006-03-19
: Modified by CptnAhab
:* Factored out Auth, Files, Tags, RemoteProxy
:* Created Configuration, DefaultConfiguration, Partner
:* Added YAML config file support (via PyYaml3000)

; v0.1 - 2006-01-02
: Written by Manpreet Singh
:* First release


</t>
<t tx="ahab.20060424002321.2">== Requirements ==

* [http://www.python.org/ Python 2.3] or higher
* [http://pyyaml.org/wiki/PyYAML PyYaml3000] (optional)


</t>
<t tx="ahab.20060424002321.3">== License ==

This software is [http://opensource.org/licenses/mit-license.php MIT licensed]:

&lt;blockquote&gt;
Permission is hereby granted, free of charge, to any person 
obtaining a copy of this software and associated 
documentation files (the "Software"), to deal in the 
Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, 
sublicense, and/or sell copies of the Software, and to 
permit persons to whom the Software is furnished to do so, 
subject to the following conditions:
&lt;/blockquote&gt;

&lt;blockquote&gt;
The above copyright notice and this permission notice shall 
be included in all copies or substantial portions of the 
Software.
&lt;/blockquote&gt;

&lt;blockquote&gt;
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS 
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR 
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
&lt;/blockquote&gt;

</t>
<t tx="ahab.20060424002321.4">== Overview ==

The openomy-python bindings are intended to provide a simple, consistent, cross-platform interface for managing and interacting with Openomy applications, users, tags, and files.  The bindings are intended to support  developers writing both [[How_Web_Apps_Work|web-based]] and [[How_Non-Web_Apps_Work|non-web-based]] applications.


</t>
<t tx="ahab.20060424002321.5">== Structure ==

The bindings are broken into three seperate layers, with each layer becoming progressively more object-abstracted.

</t>
<t tx="ahab.20060424002321.6">== EpyDoc Reference ==

A complete listing of members and methods of this class is available [http://cptnahab.googlepages.com/openomy.DefaultConfiguration-class.html here].


</t>
<t tx="ahab.20060424002321.7">== Related Classes ==

See also:
* [[openomy.py/Configuration|Configuration]]
* [[openomy.py/API|API]]</t>
<t tx="ahab.20060424002321.8">The Auth class is composed of static methods for each of the openomy Auth API methods.

</t>
<t tx="ahab.20060424002321.9">The Files class is composed of static methods for each of the openomy Files API methods:


</t>
<t tx="ahab.20060424002321.10">The Tags class is composed of static methods for each of the openomy Tags API methods:
</t>
<t tx="ahab.20060424002321.11">The User class is a [[openomy.py/RemoteProxy|remote proxy]] subclass representing an Openomy user.


</t>
<t tx="ahab.20060424002321.12">The AutoLoginUser class is a [[openomy.py/User|User]] subclass with username/password login capacity.

</t>
<t tx="ahab.20060424002321.13">The AutoRegisterUser class is an [[openomy.py/AutoLoginUser|AutoLoginUser]] subclass with username/password/email registration capacity.

</t>
<t tx="ahab.20060424002321.14">The File class represents a file accessible on a [[openomy.py/User|user]]'s [[openomy.py/RemoteProxy|remote]] Openomy account.


</t>
<t tx="ahab.20060424002321.15">The Tag class represents a [[openomy.py/RemoteProxy|remote]] tag belonging to or shared with an Openomy [[openomy.py/User|user]].


</t>
<t tx="ahab.20060424002321.16">== Example ==

The example program downloads the contents of an Openomy account to a local directory, skipping any pre-existing files.

This example demonstrates the following library interactions:
* Library import
* User object instantiation
* User file list querying
* File downloading

&lt;blockquote&gt;&lt;pre&gt;    
    #!/usr/bin/env python
    
    import os, os.path
    import openomy
    
    destdir = os.path.expanduser("~/Openomy")
    if not os.path.exists(destdir):
      os.makedirs(destdir)
    
    # Get a local file list
    files = os.listdir(destdir)
    
    # The openomy.User object automatically 
    # manages the user login, keys, and tokens.
    # Settings will be automatically loaded from 
    # and saved to "~/.openomy/openomy.ini" (or .yml)
    
    # We don't want to load the tag list, just 
    # download files.  So, no auto-refresh.
    u = openomy.User(refresh=False)
    
    # Refresh and sort the remote file list
    rfiles = u.GetAllFiles()
    rfiles = [rfile.name, rfile for rfile in rfiles]
    rfiles.sort()
    
    for fname, rfile in rfiles:  
      # Download each item we don't already have.
      if fname not in files:
        print "Downloading %s..." % fname,
        filename = os.path.join(destdir, fname)
        rfile.download(filename)
        print "done.\n"
      else:
        print "Skipping %s...already exists.\n" % rfile.name
&lt;/pre&gt;&lt;/blockquote&gt;        
</t>
<t tx="ahab.20060424002340">The Partner class is an [[openomy.py/RemoteProxy|RemoteProxy]] subclass representing a non-active user.
</t>
<t tx="ahab.20060424003925">== Using the Library ==

Select one of the following library components for more information on usage:

*; [[openomy.py]]
: core python bindings for managing openomy interaction
*; [[openomy_fs.py]]
: FUSE python interface for Openomy
*; [[openomy_update.py]]
: tool to keep your openomy-python bindings and tools up-to-date
*; [[openomy_sync.py]]
: full-strength bi-directional file synchronizer.

</t>
<t tx="ahab.20060424003925.1">== Download ==

The most up-to-date versions of the openomy-python bindings and tools are currently available via openomy rss.  An [http://rss.openomy.com/download/get/1084 updater tool] has been provided to download/update your library to the latest release version.  Simply download it and execute it in whichever directory you'd like openomy-python to be stored.

Alternatively, subscribe to the [http://rss.openomy.com/rss/crawfles/openomy_py openomy-python rss feed] for regular updates.

   
</t>
<t tx="ahab.20060424003925.2">This page describes the OpenomyFS python FUSE mount.</t>
<t tx="ahab.20060424011950">== EpyDoc Reference ==

A complete specification of Auth class methods and members is available [http://cptnahab.googlepages.com/openomy.Auth-class.html here].


</t>
<t tx="ahab.20060424012520">== Methods ==

* Auth.GetUnconfirmedToken()
* Auth.GetConfirmedToken(uncfmToken)
* Auth.RegisterUser(username, password, email)
* Auth.AuthorizeUser(username, password)

All of the parameters identified in the [[Currently_Supported_Methods|REST API documentation]] are optional, with defaults coming from the DefaultConfiguration, loaded default Configuration object, or the additional optional keyword parameter ''config''.  This can be used to pass an alternate configuration object to override the default keys, tokens, username, password, email, etc.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy    
    
    myConfig = openomy.Configuration(default=False)
    myConfig.applicationKey = "some app key"
    myConfig.privateKey = "some priv key"
    
    # Pass our changed configuration object
    cfmToken = openomy.Auth.AuthorizeUser(
                config=myConfig)
    if not cfmToken:
        raise "Could not obtain a confirmed token."
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060424012520.1">== Related Classes ==

See also:
* [[openomy.py/API|API]]
* [[openomy.py/Configuration|Configuration]]
* [[openomy.py/DefaultConfiguration|DefaultConfiguration]]
* [[Openomy.py/Files|Files]]
* [[Openomy.py/Tags|Tags]]

</t>
<t tx="ahab.20060424012520.2">== Methods ==

* Files.GetFile(fileID)
* Files.AddFile(filename, tagID)
* Files.DeleteFile(fileID)
* Files.ModifyFile(fileID, filename)
* Files.GetAllFiles()

Each method also takes an optional keyword parameter, ''config'', to identify any keys/tokens for the logged-in user.  The default Configuration or DefaultConfiguration will be searched if a ''config'' argument is not supplied.

In the case of AddFile and ModifyFile, the methods take a ''filename'' parameter in place of ''fileField''.  ''filename'' should contain the full local path to a file to be uploaded to Openomy.

    import openomy    
    
    # App-wide default configuration
    cfg = openomy.Configuration()
    
    # Log in
    cfmToken = openomy.Auth.AuthorizeUser()
    if not cfmToken:
        raise "Could not obtain a confirmed token."
    cfg.set("confirmedToken", cfmToken)
    
    # Upload the most recent copy of a certain file
    openomy.Files.ModifyFile(12345, "~/status.txt")
    </t>
<t tx="ahab.20060424012520.3">== EpyDoc Reference ==

A complete specification of Files class methods and members is available [http://cptnahab.googlepages.com/openomy.Files-class.html here].


</t>
<t tx="ahab.20060424012520.4">== Related Classes ==

See also:
* [[Openomy.py/Auth|Auth]]
* [[Openomy.py/Tags|Tags]]
* [[openomy.py/Configuration|Configuration]]
* [[openomy.py/DefaultConfiguration|DefaultConfiguration]]
</t>
<t tx="ahab.20060513132332">== Methods ==

* Tags.GetTag(tagID)
* Tags.CreateTag(tagName)
* Tags.DeleteTag(tagID)
* Tags.AddFileToTag(fileID, tagID)
* Tags.DeleteFileFromTag(fileID, tagID)
* Tags.GetAllTags()

Each method also takes an optional keyword parameter, ''config'', to identify any keys/tokens for the logged-in user.  The default Configuration or DefaultConfiguration will be searched if a ''config'' argument is not supplied.

</t>
<t tx="ahab.20060513132332.1">== EpyDoc Reference ==

A complete specification of Files class methods and members is available [http://cptnahab.googlepages.com/openomy.Files-class.html here].

</t>
<t tx="ahab.20060513132559">== Related Classes ==

See also:
* [[Openomy.py/Auth|Auth]]
* [[Openomy.py/Files|Files]]
* [[openomy.py/Configuration|Configuration]]
* [[openomy.py/DefaultConfiguration|DefaultConfiguration]]
</t>
<t tx="ahab.20060513134804">
def wikiSect(wikipos, subpos):
    if subpos.v == wikipos.v:
        return 0, True
        
    sectcount, found = 1, False

    child = wikipos.firstChild()
    while child and not found:
        if not child.headString().startswith("@wiki "):
            subsects, found = wikiSect(child, subpos)
            sectcount += subsects
        child = child.next()

    return sectcount, found

def wikiName(p):
    wikiname = wikiPos(p).headString()
    
    wikiname = wikiname[6:]
    if wikiname[0] == "/" and p.parent():
        # Relative wiki page, keep going
        wikiparent = wikiName(p.parent())
        wikiname = wikiparent + wikiname
        
    return wikiname
    
def wikiBase(p):
    if not p:
        raise "Could not locate @wikibase url."
        
    blines = p.bodyString().splitlines()
    for bline in blines:
        if bline.startswith("@wikibase "):
            return bline[10:]
            
    return wikiBase(p.parent())

def wikiPos(p):
    wikiname = p.headString()
    while not wikiname.startswith("@wiki "):
        p = p.parent()
        if not p:
            raise "Could not locate @wiki parent node."
        wikiname = p.headString()
    return p
    
def wikiBody(p):
    # Collect the entire body from here
    # down to the next @wiki.
    body = p.bodyString()
    
    sbody = body.strip().splitlines()
    if (len(sbody) == 1 and 
        sbody[0][0] == sbody[0][-1] == '='):
        # Make sure we end with precisely one blank line.
        body = body.strip() + "\n\n"
        
    else:
        # Make sure we end with precisely two blank lines.
        while not body.endswith("\n\n\n\n"):
            body += "\n"
        while body.endswith("\n\n\n\n"):
            body = body[:-1]
    
    child = p.firstChild()
    while child:
        if not child.headString().startswith("@wiki "):
            body += wikiBody(child)
        child = child.next()
        
    return body

def wiki(p):
    wikipos = wikiPos(p)
    wikiname = wikiName(wikipos)
    wikibase = wikiBase(wikipos)
    return wikipos, wikiname, wikibase

</t>
<t tx="ahab.20060513142459">_wiki_opener = None
def wikiOpener():
    global _wiki_opener
    if not _wiki_opener:
        cookiefile = "\\".join(["C:", "Documents and Settings",
            "Michael", "Application Data", "Mozilla", "Firefox",
             "Profiles", "63k4a7s3.default", "cookies.txt"])
        cj = cookielib.MozillaCookieJar(cookiefile)
        cj.load() 
        ch = urllib2.HTTPCookieProcessor(cj)
        _wiki_opener = urllib2.build_opener(ch)
         
    return _wiki_opener

def wikiEditToken(wikibase, wikiname):
    wikiopener = wikiOpener()
    wikiurl = wikibase + ("?title=%s&amp;action=edit" % wikiname)
    furl = wikiopener.open(wikiurl)
    wikiedit = furl.read()
    match = re.search('&lt;input[^&gt;]+value="([^\"]+)"\s+name="wpEditToken"', wikiedit)
    return match.group(1)


def wikiLoad(wikibase, wikiname, wikisection=None):
    wikiopener = wikiOpener()
    wikiurl = wikibase + ("?title=%s&amp;action=edit" % wikiname)
    if wikisection is not None:
        wikiurl += "&amp;section=%s" % wikisection
    furl = wikiopener.open(wikiurl)
    wikibody = furl.read()
    match = re.search('&lt;textarea[^&gt;]+&gt;([^&lt;]*)&lt;/textarea&gt;', wikibody)
    if not match:
        raise str(wikiurl)
    return match.group(1)


def wikiSave(wikibase, wikiname, wikibody, wikisection='',
        editsummary='', editminor=True):
            
    wikitoken = wikiEditToken(wikibase, wikiname)

    parms = {
        "title": wikiname,
        "wpSection": wikisection,
        "wpTextbox1": wikibody,
        "wpEditToken": wikitoken,
        "wpEdittime": "",
        "wpMinoredit": (editminor and "1") or "",
        "wpSummary": editsummary,
        "wpSave": "Save page"
        }.items()
        
    content_type, body = wikiForm(parms)

    wikiurl = wikibase + ("?title=%s&amp;action=submit" % wikiname)    
    wikiopener = wikiOpener()
    headers = { 'Content-type': content_type }
    req = urllib2.Request(wikiurl, body, headers)
    furl = wikiopener.open(req)
    wikiedit = furl.read()
    return wikiedit

</t>
<t tx="ahab.20060513164358">== EpyDoc Reference ==

A complete specification of the module's contents is available [http://cptnahab.googlepages.com/openomy-module.html here].</t>
<t tx="ahab.20060513164621"># ///////////////////////////////////
# Show the current wiki page/node
# in a web browser.
from leoWiki import *

wikipos, wikiname, wikibase = wiki(p)
wikiurl = "%s?title=%s" % (wikibase, wikiname)
#if wikipos.v != p.v:
#    wikiurl += "#" + urllib.urlencode(p.headString())
webbrowser.open(wikiurl)</t>
<t tx="ahab.20060513165929"># ///////////////////////////////////
# Tweak a section on the page.
from leoWiki import *

wikipos, wikiname, wikibase = wiki(p)
wikisect, found = wikiSect(wikipos, p)
if found:
    wikibody = p.bodyString()

    g.es("Wiki Base: %s" % wikibase, color="blue")
    g.es("  publishing %s..." % wikiname, color="purple")
    g.es("  section %s..." % str(wikisect), color="purple")

resultpage = wikiSave(wikibase, wikiname, wikibody,
        wikisection=str(wikisect),
        editsummary='Tweaking Section', 
        editminor=True)

g.es("Finished.", color="blue")</t>
<t tx="ahab.20060513173100">The RemoteProxy class is an abstract base class, defining methods for operating on remote objects.  You will never need to instantiate a remote proxy object, but you might want to subclass it to remote other object types.


</t>
<t tx="ahab.20060513173145">== EpyDoc Reference ==

A complete specification of RemoteProxy class methods and members is available [http://cptnahab.googlepages.com/openomy.RemoteProxy-class.html here].

</t>
<t tx="ahab.20060513173300">== Related Classes ==

See also:
* [[openomy.py/File|File]]
* [[openomy.py/Partner|Partner]]
* [[openomy.py/Tag|Tag]]
* [[openomy.py/User|User]]
</t>
<t tx="ahab.20060513173921"># ///////////////////////////////////
# Tweak a wiki page.
from leoWiki import *

wikipos, wikiname, wikibase = wiki(p)
wikibody = wikiBody(wikipos)

g.es("Wiki Base: %s" % wikibase, color="blue")
g.es("  publishing %s..." % wikiname, color="purple")

resultpage = wikiSave(wikibase, wikiname, wikibody,
        editsummary='Tweaking', 
        editminor=True)

g.es("Finished.", color="blue")</t>
<t tx="ahab.20060514144850">=== Refresh ===

The RemoteProxy class has one abstract public-scope method:

*; refresh()
*: Override in subclasses to actually reload this object from the remote data store.

The default implementation sets the object's ''_loaded'' flag to False.
</t>
<t tx="ahab.20060514144850.1">=== Event Handlers ===

The RemoteProxy class has several protected-scope methods for responding to remote data events:

*; _retrieved(obtype, obid, obname)
*: Constructs a new RemoteProxy object for us to link to.
 
*; _renamed(object, oldname)
*: Called when a related object is renamed.  Used to update our link index.

*; _updated(obtype, obdefs)
*: Called when one of our collections is updated en-masse.

*; _added(object)
*: Called when an object is added to one of our collections.

*; _removed(object)
*: Called when an object is removed from one of our collections.

These methods can be overridden in a subclass to add custom event handling.  If you do override a handler method, ensure that you call the RemoteProxy base class' handler method from within your own.</t>
<t tx="ahab.20060514151350">== Members ==

The RemoteProxy class has two protected members:

*; _remote
*: Collects details about our related objects.

*; _loaded
*: Flag indicating that we have performed a full refresh.
</t>
<t tx="ahab.20060514151350.1">== Methods ==
</t>
<t tx="ahab.20060514154047">=== Attribute Magic ===

RemoteProxy implements some ''__getattr__'' magic to ensure backwards-compatibility, and to disallow some hobgoblins (a la [http://www.python.org/dev/peps/pep-0008/ PEP 8]).

If you attempt a standard attribute access on a RemoteProxy object, and it fails, the __getattr__ mechanism will also check your identifier for either CapWords or under_score notation.  If there is a matching attribute named identically but in mixedCase notation (i.e. the implementation default), it will return the value of that attribute.
</t>
<t tx="ahab.20060514154113">== EpyDoc Reference ==

A complete specification of User class methods and members is available [http://cptnahab.googlepages.com/openomy.User-class.html here].

</t>
<t tx="ahab.20060514154523">== Related Classes ==

See also:
* [[openomy.py/File|File]]
* [[openomy.py/Partner|Partner]]
* [[openomy.py/RemoteProxy|RemoteProxy]]
* [[openomy.py/Tag|Tag]]
* [[openomy.py/AutoLoginUser|AutoLoginUser]]
* [[openomy.py/AutoRegisterUser|AutoRegisterUser]]
</t>
<t tx="ahab.20060514160357">== Members ==

The User class contains three dictionary members for linking to files, tags, and other users:

*; files
*: Collects details about our related files.

*; tags
*: Collects details about our related tags, includings tags we've created or to which we've subscribed.

*; partners
*: Collects details about other Openomy users with whom we're sharing files or tags.


Configuration state is managed by three different members:

*; config
*: A Configuration object for this User.

*; default
*: This is the default User (and thus default user Configuration) for the running application.

*; configdir
*: The full path to the local filesystem openomy configuration directory for this user.  Defaults to ''~/.openomy".

</t>
<t tx="ahab.20060514160357.2">=== Instantiation ===

The User class has one default constructor:


*; __init__(default=True, config=True, auth=True, refresh=True)
*:Create a new User remote proxy.


The User object takes up to four (4) optional arguments upon creation:

*; default
*: This object is the primary (owner) object for this collection.  Almost always true.

*; config
*: Call loadConfig() after creating the object.

*; auth
*: Call obtainAccess() after creating the object (and optionally loading the configuration)

*; refresh
*: Load any tags and files for this user after obtaining access.
    

The following example shows how to load only the file list (but exclude the user's tag list):

    import openomy
    
    # Load the configuration, and log in,
    # but don't actually load our data.
    user = openomy.User(refresh=False)
    
    # Load just the files.
    files = user.getAllFiles()
    
</t>
<t tx="ahab.20060514160611">== Methods ==
</t>
<t tx="ahab.20060514160611.1">=== Authorization (Login) ===

The User class defines several methods for negotiating the authorization of an application/user session:


*; obtainAccess()
*: Obtain authorization to access Openomy.   This is the function you'll must often call.  It manages the entire authorization process from start to finish.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User(auth=False,refresh=False)
    user.promptToAuthorize = myPrompterFunc
    user.obtainAccess()
&lt;/pre&gt;&lt;/blockquote&gt;


*; checkAuthLevel()
*: See what sort of authorization we need to do with Openomy. Checks the configuration chain for the [[Application_Key|app key]], [[Private_Key|private key]], and [[Confirmed_Token|confirmed token]].  This also automatically saves the retrieved authentication info if it has changed since the last call.  Returns 2 if an application key and private key are available, 3 if a confirmed token is also available, or 0 otherwise.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User(auth=False,refresh=False)
    auth = user.checkAuthLevel()
    status = (((auth == 3) and "Authenticated.") or
                "Not authenticated.")
    # ...
&lt;/pre&gt;&lt;/blockquote&gt;


*; obtainCfmToken()
*: Obtain a confirmed session token for this application/user combo.


*; promptToAuthorize(uncfmToken)
*: Asks the user to authenticate in their browser.  If you override this method in a subclass, you will need to generate an [[How_Non-Web_Apps_Work#The_tokens|authorization url]] from the provided unconfirmed token.

</t>
<t tx="ahab.20060514160611.2">=== Retrieving Objects ===

You can retrieve a User's tags or files with one of these methods:


*; getAllFiles()
*: Retrieve a list of file objects for this user.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()

    files = user.getAllFiles()
    for file in files:
        print "File %i: %s" % (file.fileid, 
                    file.filename)
&lt;/pre&gt;&lt;/blockquote&gt;


*; getAllTags()
*: Retrieve a list of tag objects for this user.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()
    
    tags = user.getAllTags()
    for tag in tags:
        print "Tag %s" % tag.tagname
        tag.refresh()
        for file in tag.files():
            print "    File %i: %s" % (file.fileid, 
                    file.filename)        
&lt;/pre&gt;&lt;/blockquote&gt;

</t>
<t tx="ahab.20060514160755">=== Creating Objects ===

The user class provides two methods for adding content to Openomy.  You can create a new tag or upload a file with one of these methods:


*; addFile(localsrc, tag=None)
*: Upload the file ''localsrc'' to the User's Openomy account, optionally tagged with ''tag''.  Returns a new [[openomy.py/File|File]] remote proxy.  This does not automatically refresh the returned File; to do so, call its ''refresh()'' method:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()

    file = user.addFile('~/myFile.txt')
    # Load the new file's remote attributes
    file.refresh()
    print "File %i: %s" % (file.fileid, file.filename)
&lt;/pre&gt;&lt;/blockquote&gt;


*; createTag(name)
*: Create a tag named ''name'' on this User's Openomy account.  Returns a new [[openomy.py/Tag|Tag]] remote proxy.  This does not automatically refresh the returned Tag; to do so, call its ''refresh()'' method:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()

    file = user.addFile('~/myFile.txt')
    # Load the new file's remote attributes
    file.refresh()
    print "File %i: %s" % (file.fileid, file.filename)
&lt;/pre&gt;&lt;/blockquote&gt;

</t>
<t tx="ahab.20060514161534">=== Configuration ===

The User class defines one method for loading a user's configuration from disk:


*; loadConfig()
*: Load a [[openomy.py/Configuration|Configuration]] for this user.

Other User methods (as well as linked Tag and File methods) will pass the loaded Configuration to identify the user in any Openomy [[openomy.py/API|API]] calls.

    import openomy
    
    user = openomy.User(config=False, auth=False, refresh=False)
    # Specify a non-default configuration directory
    user.configDir = "/etc/openomy"
    user.loadConfig()
    user.obtainAccess()
    
    # ...</t>
<t tx="ahab.20060514170859"># leoWiki.py
# Leo script functions for
# @wiki nodes.

# Usage:
#   Headline: 
#       @wiki Here
#       @wiki /Relative
#   Body:
#       @wikibase http://en.wikipedia.org/

&lt;&lt; Wiki Scripts &gt;&gt;

if __name__ == '__main__':
    @others

</t>
<t tx="ahab.20060514170859.1">c.save()</t>
<t tx="ahab.20060514170859.2">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    #head = p.moreHead(firstLevel)
    #head = g.toEncodedString(head,'ascii',reportErrors=True)
    #result.append(head)
    #body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    body = p.bodyString()
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ahab.20060514171321">import urllib, urllib2, urlparse, cookielib
import webbrowser
import re

@others</t>
<t tx="ahab.20060514173814">c.frame.toggleSplitDirection()</t>
<t tx="ahab.20060514192458">== Members ==

The AutoLoginUser class contains two protected members for storing the account name and password:

*; _username
*: User's account name (or email address)

*; _password
*: User's account password

</t>
<t tx="ahab.20060514192458.1">== Methods ==
</t>
<t tx="ahab.20060514192458.2">=== Instantiation ===

The AutoLoginUser class has but one constructor:


*; __init__(username, password, config=True, auth=True, refresh=True)
*:Create a new AutoLoginUser user proxy with ''username''/''password'' credentials.

See the [[openomy.py/User|User]] parent class documentation for details about the three [[openomy.py/User#Instantiation|optional arguments]].


The following example shows how to automatically login and retrieve the a list of the users tags:

    import openomy
    
    # Load the configuration, and log in,
    # but don't actually load our data.
    user = openomy.AutoLoginUser("ishmael", "qu33'qu36")
    
    # Just the tags.
    tags = user.getAllTags()
    for tag in tags:
        print "Tag %s" % tag.tagname
    

</t>
<t tx="ahab.20060514192458.3">=== Login ===

In order to use the provided credentials, the AutoLoginUser overrides the following [[openomy.py/User|User]] method:

*; obtainCfmToken()
*: Uses the Auth.AuthorizeUser call to obtain a confirmed token.  NOTE:  If successful, this will also save the retrieved confirmedToken back to disk via the User's [[openomy.py/Configuration|Configuration]].

You should not need to call this method directly unless you are manually handling your own authentication process.</t>
<t tx="ahab.20060514194447">== EpyDoc Reference ==

A complete specification of AutoLoginUser class methods and members is available [http://cptnahab.googlepages.com/openomy.AutoLoginUser-class.html here].

</t>
<t tx="ahab.20060514194447.1">== Related Classes ==

See also:
* [[openomy.py/AutoRegisterUser|AutoRegisterUser]]
* [[openomy.py/User|User]]

</t>
<t tx="ahab.20060514200659">== Members ==

The AutoRegisterUser class contains a protected member for storing the User's email address:

*; _email
*: User's email address for account registration
</t>
<t tx="ahab.20060514201242">== Methods ==

</t>
<t tx="ahab.20060514201242.1">=== Instantiation ===

The AutoRegisterUser class has one default constructor:


*; __init__(username, password, email, config=True, auth=True, refresh=True)
*:Create a new AutoRegisterUser user proxy with ''username''/''password'' credentials, and ''email'' address email.

See the [[openomy.py/User|User]] ancestor class documentation for details about the three [[openomy.py/User#Instantiation|optional arguments]].


The following example shows how to automatically login (registering the user if necessary) and retrieve the a list of the users tags:

    import openomy
    
    # Load the configuration, and log in,
    # but don't actually load our data.
    user = openomy.AutoRegisterUser("ishmael", "qu33'qu36", "ishmael@pequod.net")
    
    # Just the tags.
    tags = user.getAllTags()
    for tag in tags:
        print "Tag %s" % tag.tagname
    

Of course, the list of tags returned in the above example would be empty for a newly registered account.</t>
<t tx="ahab.20060514201242.2">=== Login ===

In order to use the provided credentials, the AutoRegisterUser overrides the following [[openomy.py/User|User]] method:

*; obtainCfmToken()
*: Uses the Auth.AuthorizeUser call to obtain a confirmed token.  If the user is not already register, uses the Auth.RegisterUser call to register the user and obtain a confirmed token.  NOTE:  If successful, this will also save the retrieved confirmedToken back to disk via the User's [[openomy.py/Configuration|Configuration]].

You should not need to call this method directly unless you are manually handling your own authentication process.</t>
<t tx="ahab.20060514202805">== EpyDoc Reference ==

A complete specification of AutoRegisterUser class methods and members is available [http://cptnahab.googlepages.com/openomy.AutoRegisterUser-class.html here].

</t>
<t tx="ahab.20060514203124">== Related Classes ==

See also:
* [[openomy.py/AutoLoginUser|AutoLoginUser]]
* [[openomy.py/User|User]]


</t>
<t tx="ahab.20060514203816">== Members ==

The Partner class contains two dictionary members for linking to files and tags:

*; files
*: Collects details about our related files.

*; tags
*: Collects details about our related tags, includings tags we've created or to which we've subscribed.
</t>
<t tx="ahab.20060514203820">== EpyDoc Reference ==

A complete specification of Partner class methods and members is available [http://cptnahab.googlepages.com/openomy.Partner-class.html here].

</t>
<t tx="ahab.20060514203932">== Related Classes ==

See also:
* [[openomy.py/File|File]]
* [[openomy.py/RemoteProxy|RemoteProxy]]
* [[openomy.py/Tag|Tag]]
* [[openomy.py/User|User]]</t>
<t tx="ahab.20060514204147">== Obtaining a Partner (object) ==

References to Partner objects are collected by the owner User object:

    import openomy
    
    # Auto load config from disk, 
    # login, and 
    # download our tag list.
    user = openomy.User()
    
    # Get the list of files we're sharing 
    # with the second mate
    stubb = user.partners['stubb']
    for file in stubb.files:
        print "File %i: %s" % (file.fileid, file.filename)

</t>
<t tx="ahab.20060514205410">== Members ==

The File class contains two dictionary members for linking to [[openomy.py/Partner|partners]] and [[openomy.py/Tag|tags]]:

*; partners
*: Collects references to users with access to this file.

*; tags
*: Collects details about tags that apply to us.
</t>
<t tx="ahab.20060514205414">== EpyDoc Reference ==

A complete specification of File class methods and members is available [http://cptnahab.googlepages.com/openomy.File-class.html here].

</t>
<t tx="ahab.20060514205841">=== Instantiation ===

The RemoteProxy class has one constructor, which should be called from your subclass constructor:

*; __init__(owner, refresh=True, **kwargs)
*: Create a new remote proxy with attributes ''kwargs'', and optionally ''refresh''.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    
    class RemoteGroup(RemoteProxy):
        def __init__(self, owner, refresh, **kwargs):
            self.users = dict()
            self._remote = { 
                    "users": (self.users, Partner)
                    }
            RemoteProxy.__init__(self, owner, refresh, 
                    **kwargs)
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060514205841.1">== Methods ==
</t>
<t tx="ahab.20060514205841.2">=== Instantiation ===

The File class has one default constructor, which you shouldn't need to call directly:

*; __init__(owner, refresh=True, **kwargs)
*: Create a new File remote proxy.
</t>
<t tx="ahab.20060514205841.3">== Related Classes ==

See also:
* [[openomy.py/Partner|Partner]]
* [[openomy.py/RemoteProxy|RemoteProxy]]
* [[openomy.py/Tag|Tag]]
* [[openomy.py/User|User]]
</t>
<t tx="ahab.20060514212001">=== Obtaining a File object ===

User, Tag, and Partner objects all keep references to File objects in their ''files'' dictionary attribute:

Two ways of obtaining a File object are shown in this example:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()

    # Method 1
    file = user.addFile('~/myFile.txt')
    
    # Method 2
    code = user.tags['openomy-code']
    for file in code.files.values():
        print "File %i: %s" % (file.fileid, 
                    file.filename)
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060514212001.1">=== Retrieving a File ===

The File class provides three separate methods for retrieving a file:

*; download(filename)
*: Retrieve the remote file into the local file ''filename''.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy, webbrowser
    user = openomy.User()
    file = user.files['personal.log']
    file.download('~/personal.log.bak')
&lt;/pre&gt;&lt;/blockquote&gt;

*; getData()
*: Return the remote file's contents as a string.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy, webbrowser
    user = openomy.User()
    file = user.files['personal.log']
    print file.getData()
&lt;/pre&gt;&lt;/blockquote&gt;

*; getUrl()
*: Retrieve a url where the file can be viewed without authentication.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy, webbrowser
    user = openomy.User()
    file = user.files['personal.log']
    webbrowser.open(file.getUrl())
&lt;/pre&gt;&lt;/blockquote&gt;
    
</t>
<t tx="ahab.20060514212001.2">=== Modifying a File ===

Sometimes, you'll want to change the contents of a file that already exists on a User's openomy account.  To do this, use the upload method:

*; upload(filename, refresh=True)
*: Upload the local file ''filename'' and optionally ''refresh'' our metadata.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    # Login
    user = openomy.User()
    # Get a reference
    myLog = user.files['personal.log']
    # Update the file
    myLog.upload('~/personal.log')
    print "Update stamp: %s" % myLog.updated
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060514212342">=== Discarding a File ===

To remove a file from a [[openomy.py/User|User]]'s Openomy account, use the delete method:

*; delete()
*: Remove this file from the owner User's account.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    # Login
    user = openomy.AutoLoginUser("starbuck", "scrimshaw")
    # Get a reference to the file
    myLog = user.files['personal.log']
    # Destroy the evidence.
    myLog.delete()
&lt;/pre&gt;&lt;/blockquote&gt;

</t>
<t tx="ahab.20060514212909">== Members ==

The Tag class contains two dictionary members for linking to [[openomy.py/Partner|partners]] and [[openomy.py/File|files]]:

*; partners
*: Collects references to users with access to this tag.

*; files
*: Collects details about files to which we apply.
</t>
<t tx="ahab.20060514212914">== Related Classes ==

See also:
* [[openomy.py/File|File]]
* [[openomy.py/Partner|Partner]]
* [[openomy.py/RemoteProxy|RemoteProxy]]
* [[openomy.py/User|User]]
</t>
<t tx="ahab.20060514213758">=== Tagging and Untagging ===

Two File methods are available for tagging and untagging the file:

*; addToTag(tag)
*: Tag this file with ''tag'', which can be either a Tag instance or a string tagname.

*; removeFromTag(tag)
*: Untag this file from ''tag'', as above.

These methods simply locate the appropriate [[openomy.py/Tag|Tag]] object and call its ''addFile'' and ''removeFile'' methods.

This example shows both adding and removing tags on a file:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()
    
    wrongTagName = 'wrongTag'
    wrightTagName = 'wilbur'
    file = user.addFile('~/myFile.txt', wrongTagName)

    wrongTag = user.tags[wrongTagName]
    file.removeFromTag(wrongTag)
    
    wrightTag = user.tags[wrightTagName]
    file.addToTag(wrightTag)
    
    assert(file in wrightTag.files.values() and 
                 file not in wrongTag.files.values())
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060514213758.1">== Methods ==
</t>
<t tx="ahab.20060514213758.2">=== Instantiation ===

The Tag class has one default constructor, which you shouldn't need to call directly:

*; __init__(owner, refresh=True, **kwargs)
*: Create a new tag remote proxy.
</t>
<t tx="ahab.20060514213758.3">=== Obtaining a Tag object ===

User, File, and Partner objects all keep references to Tag objects in their ''tags'' dictionary attribute. Two ways of obtaining a Tag object are shown in this example:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()

    # Method 1
    tag = user.createTag('MyFirstTag')
    
    # Method 2
    tag = user.tags['MyFirstTag']
    
    print "Tag %i created %s" % (tag.tagid, tag.created)
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060514213758.4">=== Tagging and Untagging ===

Two methods are available for tagging and untagging [[openomy.py/File|remote files]]:

*; addFile(file)
*: Tag this ''file'', which can be either a File object or a string filename.

*; removeFile(file)
*: Untag this ''file'', as above.

This example shows both adding and removing tags on a file:

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    user = openomy.User()
    
    wrongTagName = 'wrongTag'
    wrightTagName = 'orville'
    file = user.addFile('~/myFile.txt', wrongTagName)

    wrongTag = user.tags[wrongTagName]
    wrongTag.removeFile(file)
    
    wrightTag = user.tags[wrightTagName]
    wrightTag.addFile(file)
    
    assert(file in wrightTag.files.values() and 
                 file not in wrongTag.files.values())
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060514213758.5">== EpyDoc Reference ==

A complete specification of Tag class methods and members is available [http://cptnahab.googlepages.com/openomy.Tag-class.html here].

</t>
<t tx="ahab.20060515111402">== Members ==

The DefaultConfiguration class defines and uses the following data members:


*; applicationKey
*: The default Openomy [[Application_Key|application key]].

*; privateKey
*: The default [[Private_Key|private key]] to be used with the applicationKey.

*; confirmedToken
*: A [[Confirmed_Token|confirmed token]] to be used with the application key/private key.


*; username
*: The default Openomy account name for authorization.

*; password
*: The password for the above-named Openomy account.

*; email
*: The email address for registering the default Openomy account.</t>
<t tx="ahab.20060515114442">== Methods ==
</t>
<t tx="ahab.20060515115004">== Members ==

The Configuration class has three protected members for managing the loading, saving, and in-memory manipulation of configuration details:

*; _path
*: Full local pathname to the configuration directory.

*; _name
*: Base file name (extension optional) for the configuration file.

*; _values
*: A dictionary mapping configuration directive names to values.
</t>
<t tx="ahab.20060515123141">== Syntax ==

* Command-line usage (help)

&lt;blockquote&gt;
    '''openomy_sync.py''' ['''-h''']
&lt;/blockquote&gt;

* Synchronization
    
&lt;blockquote&gt;
    '''openomy_sync.py'''  ['''-a''' ''&lt;user&gt;'' | '''--acct='''''&lt;user&gt;''] 
    
                           ['''-p''' ''&lt;pass&gt;'' | '''--pass='''''&lt;pass&gt;''] 
                           
                           ['''-e''' ''&lt;address&gt;'' | '''--email='''''&lt;address&gt;'']
                           
                           ['''-t''' ''&lt;tag&gt;'' | '''--tag='''''&lt;tag&gt;'']
                           
                           ['''-b''' ''&lt;basedir&gt;'' | '''--base='''''&lt;base&gt;'']
                           
                           [ ['''-d''' | '''--download'''] | ['''-u''' | '''--upload'''] ]
&lt;/blockquote&gt;


</t>
<t tx="ahab.20060515123141.1">== Options ==


{| width="400px" border="1" align="center" cellspacing="0" cellpadding="4" bordercolor="#cccccc"

! Short
! Long
! Description
|-

|  -h   
| --help 
| show this help message and exit 
|-

| -a USER 
| --acct=USER 
| authenticate with account USER 
|-

| -p PASS 
| --pass=PASS 
| authenticate with password PASS 
|-

| -e EMAIL 
| --email=EMAIL
| register new user with email EMAIL
|-

| -t TAG 
| --tag=TAG 
| synchronize with TAG 
|-

| -b BASE 
| --base=BASE 
| set base directory for synchronization to BASE 
|-

| -d 
| --download 
| download only; do not upload anything 
|-

| -u 
| --upload 
| upload only; do not download anything 

|}
</t>
<t tx="ahab.20060515125944.1">== Examples ==

The simplest invocation of ''openomy_sync.py'' automatically synchronizes the contents of your openomy account with the current working directory:

&lt;blockquote&gt;&lt;pre&gt;
~$  openomy_sync.py
&lt;/pre&gt;&lt;/blockquote&gt;


To synchronize with a directory other than the current one, add the full path to the end of the command:

&lt;blockquote&gt;&lt;pre&gt;
~$   openomy_sync.py    ~/pub/openomy
&lt;/pre&gt;&lt;/blockquote&gt;


To synchronize only an openomy tag (not our entire account), use the ''-t'' command line argument:

&lt;blockquote&gt;&lt;pre&gt;
~$   openomy_sync.py    -t openomy_code    ~/pub/openomy
&lt;/pre&gt;&lt;/blockquote&gt;


To ensure that your local copy is used the master (i.e. Upload to Openomy only -- don't download), use the ''-u'' switch:

&lt;blockquote&gt;&lt;pre&gt;
~$   openomy_sync.py    -t openomy_code   -u    ~/pub/openomy
&lt;/pre&gt;&lt;/blockquote&gt;</t>
<t tx="ahab.20060515130317">== Syntax ==

* Update your openomy-python library

&lt;blockquote&gt;
    '''openomy_update.py'''
&lt;/blockquote&gt;

This will download the most up-to-date versions of the openomy-python library to the current directory.
</t>
<t tx="ahab.20060515170858">== Introduction ==

OpenomyFS-Python is a python implementation of OpenomyFS Ruby that allows you to mount your Openomy files using FUSE.</t>
<t tx="ahab.20060515170858.1">== Pre-Requisites ==

# Download FUSE from fuse.sf.net. It involves a kernel module, a userspace library and some utilities. Linux kernel 2.6.14 onwards comes with the FUSE kernel module.
# You need to register at the openomy website by creating an account and also obtaining a "private key" and an "application key" which are needed to be replaced (between quotes) in the "openomy.py" file.   ''Update'' (version '''0.3'''): you can place your configuration details in the default openomy configuration file.
# You also need to install python on your machine. The code was written using a python 2.4 implementation.
# Download and install python FUSE bindings from the FUSE cvs repository, the instructions for which are on 'fuse.sf.net' under the "language bindings" link.</t>
<t tx="ahab.20060515170858.2">== Usage ==

Mount:

&lt;blockquote&gt;&lt;pre&gt;
./openomyfs.py ''&lt;mount point&gt;'' &amp;
&lt;/pre&gt;&lt;/blockquote&gt;


Unmount:

&lt;blockquote&gt;&lt;pre&gt;
fusermount -u ''&lt;mount point&gt;''
&lt;/pre&gt;&lt;/blockquote&gt;


Kill the process:

&lt;blockquote&gt;&lt;pre&gt;
kill -9 ''&lt;the process started above&gt;''
&lt;/pre&gt;&lt;/blockquote&gt;
or
&lt;blockquote&gt;&lt;pre&gt;
killall -9 python
&lt;/pre&gt;&lt;/blockquote&gt;


On the first run, a browser will open asking you to authorize this application to access your openomy account. After that, a confirmation key obtained is used on all subsequent runs. 
The key is saved in ''~/.openomy/confirmation_key''.  ''Update (version '''0.3'''):''  All configuration has moved to ''~/.openomy/openomy.ini'' (or .yml); applications will now authorize themselves, and even register a user if enough information is available in the configuration file.</t>
<t tx="ahab.20060515170858.3">== Directory Structure ==

Under the mount point, all files from your openomy account are present in the root directory. 

There is also a subdirectory named 'tags' that contains directories, each representing a tag previously created. Copying a file from the main directory into one of the tag directories has the effect of adding the tag to the file.

</t>
<t tx="ahab.20060515170858.4">== Relevant Links ==

* http://www.openomy.com
* http://fuse.sf.net
 </t>
<t tx="ahab.20060515171532">== Version History ==


; v0.3 - 2006-05-20
: Modified by CptnAhab
:* Adjusted to new openomy-python bindings

; v0.1 - 2006-01-02
: Written by Manpreet Singh
:* First release


</t>
<t tx="ahab.20060515230058">=== Discarding a Tag ===

To remove a tag from a [[openomy.py/User|User]]'s Openomy account, use the delete method:

*; delete()
*: Remove this tag from the owner User's account.

&lt;blockquote&gt;&lt;pre&gt;
    import openomy
    # Login
    user = openomy.AutoLoginUser("starbuck", "scrimshaw")
    # Get a reference to the tag
    myTag = user.tags['staleTag']
    # Throw it away.
    myTag.delete()
&lt;/pre&gt;&lt;/blockquote&gt;

</t>
<t tx="ahab.20060517091304">
def links(self, linktype):
    if linktype not in self._remote:
        return
    
    done = list()
    index = self._remote[linktype][0]
    for link in index:
        if index[link] not in done:
            done.append(index[link])
            yield index[link]

</t>
<t tx="ahab.20060517091732">
##################################################################################################
#
#   openomyfs v0.1: A FUSE (fuse.sf.net) based file system to mount your Openomy (openomy.com)
#			files on a Linux box.
#
#   v0.3 : CptnAhab     2006-05-20
#       Updated to newer openomy-python interface
#   v0.1 : Manpreet Singh 2006-01-02
#   		First release
#
#   Copyright (C) 2005-2006 Manpreet Singh (manpreet_singh@users.sourceforge.net)
#   Copyright (C) 2006 CptnAhab (cptnahab@gmail.com)
#
#   Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
#   associated documentation files (the "Software"), to deal in the Software without restriction,
#   including without limitation the rights to use, copy, modify, merge, publish, distribute,
#   sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
#   furnished to do so, subject to the following conditions:
#
#   The above copyright notice and this permission notice shall be included in all copies or substantial
#   portions of the Software.
#
#   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
#   LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
#   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
#   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
##################################################################################################

</t>
<t tx="ahab.20060517092249">def link(self, path, path1):
    pass

</t>
<t tx="ahab.20060517095207"></t>
<t tx="ahab.20060517095320">updated:
Wed, 17 May 2006 08:56:23 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 23, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/1084', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy_update.py

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy_update.py', 'language': None}

link:
http://rss.openomy.com/download/get/1084

id:
http://rss.openomy.com/rss/crawfles/26c63fe227c463ce3312b2a846a8a760a90b518d
</t>
<t tx="ahab.20060517095320.1">updated:
Wed, 17 May 2006 08:56:22 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 22, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/1085', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy_sync.py

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy_sync.py', 'language': None}

link:
http://rss.openomy.com/download/get/1085

id:
http://rss.openomy.com/rss/crawfles/c54072661403952d1d86d1f247d6e0b2e407d08f
</t>
<t tx="ahab.20060517095320.2">updated:
Wed, 17 May 2006 08:56:21 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 21, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/1086', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy_fs.py

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy_fs.py', 'language': None}

link:
http://rss.openomy.com/download/get/1086

id:
http://rss.openomy.com/rss/crawfles/ebf8cee19f7785982c604cc9209a6af02d4112f4
</t>
<t tx="ahab.20060517095320.3">updated:
Wed, 17 May 2006 08:56:20 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 20, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/1087', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy_download.py

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy_download.py', 'language': None}

link:
http://rss.openomy.com/download/get/1087

id:
http://rss.openomy.com/rss/crawfles/fdea8a851b4d61c69ad129721ea5baa952226827
</t>
<t tx="ahab.20060517095320.4">updated:
Wed, 17 May 2006 08:56:19 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 19, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/900', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy.py

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy.py', 'language': None}

link:
http://rss.openomy.com/download/get/900

id:
http://rss.openomy.com/rss/crawfles/671e03847440bb93ef1fdc3daf1de71db987f624
</t>
<t tx="ahab.20060517095320.5">updated:
Wed, 17 May 2006 08:56:16 -0500

updated_parsed:
(2006, 5, 17, 13, 56, 16, 2, 137, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/1088', 'type': 'text/html', 'rel': 'alternate'}]

title:
openomy-python.leo

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'openomy-python.leo', 'language': None}

link:
http://rss.openomy.com/download/get/1088

id:
http://rss.openomy.com/rss/crawfles/1651d87532080e82745c247ddb2042ad48b92270
</t>
<t tx="ahab.20060517095320.6">updated:
Mon, 03 Apr 2006 09:04:58 -0500

updated_parsed:
(2006, 4, 3, 14, 4, 58, 0, 93, 0)

links:
[{'href': u'http://rss.openomy.com/download/get/901', 'type': 'text/html', 'rel': 'alternate'}]

title:
license.txt

guidislink:
False

title_detail:
{'base': u'http://rss.openomy.com/rss/crawfles/openomy_py', 'type': 'text/plain', 'value': u'license.txt', 'language': None}

link:
http://rss.openomy.com/download/get/901

id:
http://rss.openomy.com/rss/crawfles/4aa462d2d84448118e8ef85dca6f4750d1c534cf
</t>
<t tx="ahab.20060517155900">def mknod(self, path, mode, dev):
    if not S_ISREG(mode) | S_ISFIFO(mode) | S_ISSOCK(mode):
        return -EINVAL

    tagname, tagfile, filename = self._splitpath(path)
    
    if filename and filename in self.user.files:
        return 0
    elif tagfile and tagfile not in self.user.files:
        return -1
    elif tagname and tagname not in self.user.tags:
        return -1
    elif not (filename or tagfile):
        return -1
    
    if filename:
        params = { "method": "Files.AddFile" }
        upload_files = [('fileField', filename, "")]
    
        response = openomy.API.dispatch(params,
                                files=upload_files,
                                config=self.user.config)
        if not response:
            return -1
    
        # Return the newly created file id.
        fileID = openomy.API.extractId(response, "file id")
    
        # Notify the owner
        self.user._retrieved("file", fileID, filename)
        
    elif tagfile:
        tag = self.user.tags[tagname]
        file = self.user.files[tagfile]
        file.addToTag(tag)
        
    return 0

</t>
<t tx="ahab.20060518153509">#!/usr/bin/env python
""" openomy_server: Python Server for the Openomy REST/Download API

    @version    0.1
    @license    Free Software.  See LICENSE.TXT for details.
    @copyright  API Copyright (C) 2005-2006 Openomy LLC
    @copyright  Server Copyright (C) 2006-2007 CptnAhab 
                    &lt;cptnahab@gmail.com&gt;

    Version History
    ===============
    v0.1 : CptnAhab 2007-02-07
         Supports standard API methods, as well as
                some Debug.* methods
         Runs under Paste as standalone or using 
                Apache mod_python
         Relocatable from root via environment var
         
         

    TODO
    ===============
    * New Url.* management methods
    * Switchable storage back-ends
        * SQLite
        * MySQL
        * PostgreSQL
    * Switchable access front-ends
        * S3 API
        * GData Storage API
    * Unit tests from openomy_test
"""

&lt;&lt; Imports &gt;&gt;

@others


</t>
<t tx="ahab.20060518153509.1"># Error handling
from paste.httpexceptions import HTTPExceptionHandler, HTTPNotFound
from paste.exceptions.errormiddleware import ErrorMiddleware
from paste.translogger import TransLogger

# Request, Response objects
from paste.wsgiwrappers import WSGIRequest, WSGIResponse

# Root url mapping
from paste.urlmap import URLMap

# Database service
from kirbybase import KirbyBase, KBError
import os, os.path

# Record timestamps
import datetime

# Random id generation
import random

# Key generation
import md5, sha

</t>
<t tx="ahab.20060518153509.5">


def fixReadLine(obj):
    
    def readline(lines=None):
        return obj.oldReadline()
    
    obj.oldReadline = obj.readline
    obj.readline = readline
    return readline


class Request(WSGIRequest):

  def __init__(self, environ):
    WSGIRequest.__init__(self, environ)
    
    # Fix-up the readline to accept, but ignore
    # the max-length argument
    fixReadLine(self.environ['wsgi.input'])

    # Setup some extra request values    
    self.db = KirbyBase('server')
    environ['wsgi.response'] = WSGIResponse(mimetype="text/xml")

    # Setup the request root
    server = self.environ['HTTP_HOST']
    rootpath = ""
    if 'OPENOMY_APP_ROOT' in self.environ:
        rootpath = self.environ['OPENOMY_APP_ROOT']
        # Decapitate the path as necessary
        if self.environ['PATH_INFO'].startswith(rootpath):
            self.environ['PATH_INFO'] = self.environ['PATH_INFO'][len(rootpath):]
    self.environ['openomy.servicepath'] = "http://%s%s" % (server, rootpath)



</t>
<t tx="ahab.20060518203554.1">


class REST:
        
    params = { } 
    exposed = True
    
     
    @others

</t>
<t tx="ahab.20060519000431">
# Define error codes/messages.

ERR_UNKNOWN = -1
ERR_BAD_TOKEN = 0
ERR_BAD_SIG = 1
ERR_UNAUTHORIZED = 2
ERR_MISSING_ARG = 3
ERR_BAD_FILETAG = 4
ERR_BAD_TAG = 5
ERR_BAD_USER = 6
ERR_OVER_QUOTA = 7
ERR_MAX_QUOTA = 8
ERR_BAD_APP_KEY = 9
ERR_BAD_METHOD = 10


class OpenomyError(Exception):
    MESSAGES = {
        ERR_UNKNOWN: "Unknown error",
        ERR_BAD_TOKEN: "Invalid token",
        ERR_BAD_SIG: "Invalid signature",
        ERR_UNAUTHORIZED: "Permissions",
        ERR_MISSING_ARG: "Null Reference",
        ERR_BAD_FILETAG: "General",
        ERR_BAD_TAG: "Tag Name Not Valid",
        ERR_BAD_USER: "User Not Found",
        ERR_OVER_QUOTA: "File Too Large",
        ERR_MAX_QUOTA: "Out Of Storage",
        ERR_BAD_APP_KEY: "Invalid Application Key",
        ERR_BAD_METHOD: "Unknown Method"
        }
    
    CODES = dict([ (v, k) for k, v in MESSAGES.items()])
    
    def __init__(self, errCode):
        self.code = errCode
        self.message = self.MESSAGES[self.code]
        self.args = [self.message]
        




</t>
<t tx="ahab.20060519000431.1">


# Auth api

class Auth:
    
    tokens = TKN_AUTH
        
    @others

</t>
<t tx="ahab.20060519001006"></t>
<t tx="ahab.20060519001006.3">


# Files api

class Files:
    
    tokens = TKN_STD
    templates = { }
    
    @others</t>
<t tx="ahab.20060519001006.4">


# Tags api

class Tags:
    
    tokens = TKN_STD
    templates = { }
    
    @others




</t>
<t tx="ahab.20060519001346">

class exposedmethod:
    """ Staticmethod and exposed all in one """
    
    def __init__(self, func):
        self._func = func
        self.exposed = True
        
    def __call__(self, *args, **kwargs):
        return self._func(*args, **kwargs)


@others


</t>
<t tx="ahab.20060519001346.1">


def __call__(self, req):
    """ Lookup and execute the method. """
    
    try:
        # Check the method call
        self.filter(req)
               
        # Collect the arguments
        result = req.method(req, **req.callParams)
        if str(result) == result:
            req.environ['wsgi.response'].write(result)

    except OpenomyError, f:
        req.environ['wsgi.response'].status_code = 400
        req.environ['wsgi.response'].failure = f
        return self._failure(req)
        
    return self._success(req)


</t>
<t tx="ahab.20060519001346.2">




def filter(self, req):
    """ Make sure we have a semantically correct
        Openomy call. """
    
    # Check the method name.
    fv = req.params
    methName = fv.get('method', None)
    if methName not in self._methods:
        raise OpenomyError(ERR_BAD_METHOD)
    
    # Traverse to find the method
    methInfo = self._methods[methName]
    req.__dict__.update(methInfo)
    if 'params' in methInfo:
        req.methodParams = methInfo['params']
    else:
        req.methodParams = {}
    
    # Check the tokens and keys and signature
    reqTokens = req.tokens
    
    # AppToken
    if reqTokens &amp; TKN_APP:
        if 'applicationKey' not in fv:
            # Missing application key
            raise OpenomyError(ERR_MISSING_ARG)
        req.app = Application.select(req.db,
            fields=['applicationKey'],
            vals= [fv['applicationKey']], single=True)
        if req.app == ():
            raise OpenomyError(ERR_BAD_APP_KEY)
    

    # CfmToken
    if reqTokens &amp; TKN_CFM:
        if 'confirmedToken' not in fv:
            raise OpenomyError()
        req.appUser = ApplicationUser.select(req.db,
            fields=['confirmedToken'],
            vals=[fv['confirmedToken']], single=True)
        if req.appUser == ():
            raise OpenomyError(ERR_BAD_TOKEN)
        if req.appUser.appID != req.app.appID:
            raise OpenomyError(ERR_UNAUTHORIZED)
        req.user = User.select(req.db,
            vals=["==%i" % req.appUser.userID], single=True)
        if req.user == ():
            raise OpenomyError(ERR_BAD_USER)
            
    # Signature
    if reqTokens &amp; TKN_SIG:
        if 'signature' not in fv:
            raise OpenomyError(ERR_MISSING_ARG)

        # Create a comparison signature
        keylist = req.methodParams.keys()
        # print "Base Parms: %s" % keylist
        keylist.append("method")
        if reqTokens &amp; TKN_APP:
            keylist.append('applicationKey')
        if reqTokens &amp; TKN_CFM:
            keylist.append('confirmedToken')

        # @@ Don't hash the file contents.
        if 'fileField' in keylist:
            keylist.remove('fileField')
        
        for nKey in range(len(keylist)):
            key = keylist[nKey]
            if tuple(key) == key:
                keylist[nKey] = key[0]
        
        # print "Parms: %s" % keylist

        keylist.sort()
        sigdat = "".join([ "%s=%s" % (str(k), str(fv.get(k)))
                           for k in keylist if k in fv ])
        
        sigdat += req.app.privateKey
        # print "Signature data: %s" % sigdat
        sig = md5.new(sigdat).hexdigest()
    
        # Check the signature.
        if fv['signature'] != sig:
            raise OpenomyError(ERR_BAD_SIG)

    # Check and collect the parameters
    req.callParams = dict()
    for pname in req.methodParams:
        ptype = req.methodParams[pname]
        
        if (tuple(pname) != pname and 
            pname not in fv):
            # Missing required parameter
            raise OpenomyError(ERR_MISSING_ARG)
        
        # Fix the type
        if tuple(pname) == pname: 
            pname = pname[0]
            
        if pname in fv:
            val = fv[pname]
            if ptype is not None:
                try:
                    val = ptype(val)
                except TypeError:
                    raise OpenomyError(ERR_BAD_ARG)
                    
            req.callParams[pname] = val
            
    # Successfully passed the filter.
    return None



</t>
<t tx="ahab.20060519004144">


def _success(self, req):
    """ Wrap the body in a success tag. """
    message = ''.join(req.environ['wsgi.response'].content)
    if not message.endswith("\n"): message += "\n"
    if not message.startswith(" "):
        message = "  " + message
    body = "&lt;success&gt;\n%s&lt;/success&gt;" % message
    req.environ['wsgi.response'].content = [
            '&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n', 
            body]
    


</t>
<t tx="ahab.20060519121502">

# Debug api

class Debug:
    
    tokens = TKN_NONE 
    
    templates = { }
        
    @others
</t>
<t tx="ahab.20060520011211">

def GetUnconfirmedToken(req):
    # Generate a new unconfirmed token
    appUser = ApplicationUser.newInstance(
            appID=req.app.appID)
    appUser.createOffer()
    appUser.insert(req.db)
    
    uncfmToken = appUser.unconfirmedToken
 
    # The unconfirmed token is an offer by an
    # application to provide a service.
    # The user authenticates and authorizes 
    # the uncfmToken, accepting of the offer to create 
    # a confirmedToken.
    
    return req.template % {"unconfirmedToken": uncfmToken }

GetUnconfirmedToken = exposedmethod(GetUnconfirmedToken)
GetUnconfirmedToken.template = "  &lt;unconfirmedtoken&gt;%(unconfirmedToken)s&lt;/unconfirmedtoken&gt;\n"



</t>
<t tx="ahab.20060520011232">


def GetConfirmedToken(req, unconfirmedToken=None):
    # Find a confirmed token
    appUser = ApplicationUser.select(req.db,
            fields=['unconfirmedToken'],
            vals=[unconfirmedToken], single=True)
    if appUser == ():
        raise OpenomyError(ERR_UNAUTHORIZED)
    cfmToken = appUser.confirmedToken
    
    # The confirmedToken is a contract
    # between a user and an application.
    if not cfmToken:
        raise OpenomyError(ERR_UNAUTHORIZED)
    
    return req.template % {"confirmedToken": cfmToken }

GetConfirmedToken = exposedmethod(GetConfirmedToken)
GetConfirmedToken.params = {"unconfirmedToken": str}
GetConfirmedToken.exposed = True
GetConfirmedToken.template = "  &lt;confirmedtoken&gt;%(confirmedToken)s&lt;/confirmedtoken&gt;\n"


</t>
<t tx="ahab.20060520011232.1">


def AuthorizeUser(req, username=None, password=None):
    # Check the username
    user = User.select(req.db, fields=['userName'], vals=[username], single=True)
    
    # Check username for email, too
    if user == ():
        user = User.select(req.db, fields=['email'], vals=[username], single=True)
    
    # Can't find the user.
    if user == ():
        raise OpenomyError(ERR_BAD_USER)
    
    # Check the password
    if user.password != password:
        raise OpenomyError(ERR_BAD_USER)
    
    # Authorize the application
    appUser = ApplicationUser.newInstance(
                      appID=req.app.appID)
    appUser.createOffer()
    appUser.acceptOffer(user)
    appUser.insert(req.db)
    
    return req.template % {"confirmedToken": appUser.confirmedToken }
    
AuthorizeUser = exposedmethod(AuthorizeUser)
AuthorizeUser.params = { "username": str, "password": str }
AuthorizeUser.exposed = True
AuthorizeUser.template = GetConfirmedToken.template



</t>
<t tx="ahab.20060520011253">


def RegisterUser(req, username=None, password=None, email=None):
    
    # Check the username
    user = User.select(req.db, fields=['userName'], vals=[username], single=True)
    
    # Check username for email, too
    if user == ():
        user = User.select(req.db, fields=['email'], vals=[email], single=True)

    if user != ():
        raise OpenomyError(ERR_BAD_USER)
        
    # Register the User
    user = User.newInstance(userName=username, password=password, email=email)
    user.insert(req.db)
    
    # Authorize the Application
    appUser = ApplicationUser.newInstance(
                      appID=req.app.appID)
    appUser.createOffer()
    appUser.acceptOffer(user)
    appUser.insert(req.db)
        
    return req.template % {"confirmedToken": appUser.confirmedToken }
    
    
RegisterUser = exposedmethod(RegisterUser)
RegisterUser.params =  { "username": str,
    "password": str, "email": str }
RegisterUser.exposed = True
RegisterUser.template = GetConfirmedToken.template




</t>
<t tx="ahab.20060520011437">

def ListMethods(req):
    mitplt = Debug.templates['methodItem']
    
    # Collect all the method names
    methodItems = list()
    for segment in Auth, Files, Tags, Debug:
        s = [ mitplt % (segment.__name__ + "." + func)
                for func in segment.__dict__ 
                if callable(getattr(segment, func)) ]
        methodItems.extend(s)
    
    return req.template %  { "methodItems": ''.join(methodItems) }

ListMethods = exposedmethod(ListMethods)
ListMethods.exposed = True
ListMethods.params = {}
ListMethods.template = """  &lt;methods&gt;
%(methodItems)s  &lt;/methods&gt;""" + "\n"

templates["methodItem"] = "    &lt;method&gt;%s&lt;/method&gt;\n"



</t>
<t tx="ahab.20060520011458">

def Shutdown(req):
    pid = os.getpid()
    if os.name == "posix":
        import signal
        os.kill(pid, signal.SIGTERM)
    elif os.name == "nt":
        import win32api
        handle = win32api.OpenProcess(1, 0, pid)
        return (0 != win32api.TerminateProcess(handle, 0))

Shutdown = exposedmethod(Shutdown)
Shutdown.exposed = True




</t>
<t tx="ahab.20060520011458.1">

def GetRecord(req, table=None, keyval=None):
    if not globals()[table]:
        raise OpenomyError()
    table = globals()[table]
    
    record = table.select(req.db, vals=["==" + keyval], single=True)
    tabledef = table.tabledef
    if callable(tabledef): tabledef = tabledef()
    
    fieldTemplate = Debug.templates['fieldItem']
    fieldItems = list()
    for field in tabledef:
        fieldName = field.split(":")[0]
        fieldValue = getattr(record, fieldName, None)
        fieldItems.append(fieldTemplate % locals())
    
    return req.template % { "fieldItems": "".join(fieldItems),
        "tableName": table.getTableName(), "recno": record.recno }

GetRecord = exposedmethod(GetRecord)
GetRecord.params = { "table": str, "keyval": str }
GetRecord.exposed = True
GetRecord.template = """  &lt;record table="%(tableName)s" recno="%(recno)i"&gt;
    &lt;fields&gt;
%(fieldItems)s    &lt;/fields&gt;
  &lt;/record&gt;""" + "\n"



templates["fieldItem"] = """      &lt;field name="%(fieldName)s"&gt;%(fieldValue)s&lt;/field&gt;""" + "\n"




</t>
<t tx="ahab.20060520011519">

def GetTable(req, table=None):
    # Get the table definition
    if not globals()[table]:
        raise OpenomyError()
    table = globals()[table]
    tabledef = table.tabledef
    if callable(tabledef): tabledef = tabledef()
    
    # Generate the response
    fieldTemplate = Debug.templates['fieldItem']
    fieldItems = list()
    for field in tabledef:
        fieldName, fieldValue = field.split(":")
        fieldItems.append(fieldTemplate % locals())
    
    return req.template % { "fieldItems": "".join(fieldItems),
                            "tableName": table.getTableName() }

GetTable = exposedmethod(GetTable)
GetTable.params = { "table": str }
GetTable.exposed = True
GetTable.template = """  &lt;table name="%(tableName)s"&gt;
    &lt;fields&gt;
%(fieldItems)s    &lt;/fields&gt;
  &lt;/table&gt;""" + "\n"





</t>
<t tx="ahab.20060520011519.1">

def Reinitialize(req):
    """ Reinitialize the database. """
    for klass in (User, Tag, File, Application, ObjectID,
                    ApplicationUser, FileUser, TagUser, FileTag):
        # Drop the table
        klass.dropTable(req.db)
        # Recreate the table
        klass.createTable(req.db)
        # Initialize the records
        klass.initTable(req.db)
    
    
    if not os.path.exists(StoredFile.PATH):
        os.makedirs(StoredFile.PATH)
    
    return "Server reinitialized."


Reinitialize = exposedmethod(Reinitialize)
Reinitialize.exposed = True


</t>
<t tx="ahab.20060520014025">

def GetTag(req, tagID=None):
    tag = Tag.select(req.db, 
                     vals=["==%i" % tagID],
                     single=True)
    if tag == ():
        raise OpenomyError(ERR_UNAUTHORIZED)
    
    # Collect the tag users (and check the permissions)
    tagUsers = TagUser.select(req.db, 
                              fields=['tagID'], 
                              vals=["==%i" % tagID])
    authorized = False
    users = []
    for tagUser in tagUsers:
        user = User.select(req.db, 
                           vals=["==%i" % tagUser.userID], 
                           single=True)
        if user != ():
            users.append(user)
            if tagUser.canWrite:
                user.isAdmin = 1
            if (tagUser.userID == req.user.userID
                 and tagUser.canRead):
                authorized = True
    
    if not authorized:
        raise OpenomyError(ERR_UNAUTHORIZED)
    
    userTemplate = Tags.templates['userItem']
    userItems = [ userTemplate % userItem.__dict__ 
                    for userItem in users ]
    
    fileTemplate = Tags.templates['fileItem']
    fileTags = FileTag.select(req.db, 
                              fields=['tagID'], 
                              vals=["==%i" % tagID])
    files = []
    for fileTag in fileTags:
        file = File.select(req.db,
                           vals=["==%i" % fileTag.fileID],
                           single=True)
                           
        if file != ():
            files.append(file)
            file.canRead = 1
            fileUser = FileUser.select(req.db,
                               fields=['fileID', 'userID'],
                               vals=["==%i" % fileTag.fileID,
                                     "==%i" % req.user.userID],
                               single=True)
            if fileUser != () and fileUser.canWrite:
                file.canWrite = 1
            
    fileItems = [ fileTemplate % file.__dict__ 
                    for file in files ]
    
    dateTimeFormat = "%m/%d/%Y %H:%M:%S %p"
    tagInfo = { 
        "tagID": tagID,
        "tagName": tag.tagName,
        "created": tag.created.strftime(dateTimeFormat),
        "userItems": "".join(userItems),
        "fileItems": "".join(fileItems)
    }
    return req.template % tagInfo
    
GetTag = exposedmethod(GetTag)
GetTag.params = { "tagID": int }
GetTag.exposed = True
GetTag.template = """  &lt;tag id="%(tagID)i" name="%(tagName)s" created="%(created)s"&gt;
    &lt;users&gt;
%(userItems)s    &lt;/users&gt;
    &lt;files&gt;
%(fileItems)s    &lt;/files&gt;
  &lt;/tag&gt;
"""

templates["userItem"] = """      &lt;user admin="%(isAdmin)i"&gt;%(userName)s&lt;/user&gt;
"""

templates["fileItem"] = """      &lt;file id="%(fileID)i" created="%(created)s" readaccess="%(canRead)i" writeaccess="%(canWrite)i"&gt;%(fileName)s&lt;/file&gt;
"""
</t>
<t tx="ahab.20060520014210">


def CreateTag(req, tagName=None):
    # Check for a tag by this name already in this user's namespace
    tagsWithName = Tag.select(req.db, fields=['tagName'], vals=[tagName])
                              
    for tag in tagsWithName:
        tagUser = TagUser.select(req.db, 
                                 vals=["==%i" % tag.tagID, 
                                       "==%i" % req.user.userID], 
                                 single=True)
        if tagUser != ():
            raise OpenomyError(ERR_BAD_TAG)
        
    # Create the new tag
    tag = Tag.newInstance(tagName=tagName, ownerID=req.user.userID)
    tag.insert(req.db)
    
    # Add the owner permissions
    tagUser = TagUser.newInstance(tagID = tag.tagID,
                    userID=req.user.userID,
                    canRead=1, canWrite=1)
    tagUser.insert(req.db)
    
    return req.template % tag.__dict__

    
CreateTag = exposedmethod(CreateTag)
CreateTag.params = { "tagName": str }
CreateTag.exposed = True
CreateTag.template = '  &lt;tag id="%(tagID)i"&gt;%(tagName)s&lt;/tag&gt;\n'




</t>
<t tx="ahab.20060520014333">


def DeleteTag(req, tagID=None):
    # Make sure the tag exists and the user owns it
    tag = Tag.select(req.db, 
                     fields=['tagID', 'ownerID'],
                     vals=["==%i" % tagID,
                           "==%i" % req.user.userID], 
                     single=True)

    if tag == (): raise OpenomyError(ERR_UNAUTHORIZED)
        
    # Delete the tag record
    tag.delete(req.db)
    
    # Delete the TagUser records
    req.db.delete(TagUser.getTableName(), ['tagID'], ["==%i" % tagID])
    
    # Delete the FileTag records
    req.db.delete(FileTag.getTableName(), ['tagID'], ["==%i" % tagID])

    # Delete us.
    return "Tag deleted."
    
DeleteTag = exposedmethod(DeleteTag)
DeleteTag.params = { "tagID": int }
DeleteTag.exposed = True




</t>
<t tx="ahab.20060520014354">

def AddFileToTag(req, fileID=None, tagID=None):
    file = File.select(req.db, 
                       fields=['fileID', 'ownerID'], 
                       vals=["==%i" % fileID, 
                             "==%i" % req.user.userID], 
                       single=True)

    tag = Tag.select(req.db, vals=["==%i" % tagID], single=True)

    if file == () or tag == ():
        raise OpenomyError(ERR_UNAUTHORIZED)
    
    # Check the tag permissions
    if not tag.ownerID == req.user.userID:
        # Check for a tagUser
        tagUser = TagUser.select(req.db, 
                                 vals=["==%i" % tagID, 
                                       "==%i" % req.user.userID], 
                                 single=True)
        if tagUser == () or not tagUser.canWrite:
            raise OpenomyError(ERR_UNAUTHORIZED)
    
    # Check to see if the file is tagged already
    tagFile = FileTag.select(req.db, 
                             vals=["==%i" % fileID, 
                                   "==%i" % tagID], 
                             single=True)
    if tagFile != ():
            raise OpenomyError(ERR_BAD_FILETAG)
    
    # Create the tag
    tagFile = FileTag.newInstance(tagID=tagID, fileID=fileID)
    tagFile.insert(req.db)
            
    return "File added to tag."

AddFileToTag = exposedmethod(AddFileToTag)
AddFileToTag.params = { "fileID": int, "tagID": int }
AddFileToTag.exposed = True




</t>
<t tx="ahab.20060520014414">

def DeleteFileFromTag(req, fileID=None, tagID=None):
    # Load the file and tag data
    file = File.select(req.db, 
                       vals=["==%i" % fileID], 
                       single=True)

    tag = Tag.select(req.db, 
                     vals=["==%i" % tagID], 
                     single=True)
    
    # Make sure the file and tag both exist
    if () in (file, tag):
        raise OpenomyError(ERR_UNAUTHORIZED)
        
    # If the user is not the owner, see if they can edit the tag
    if tag.ownerID != req.user.userID:
        tagUser = TagUser.select(req.db, 
                                 vals=["==%i" % tagID, 
                                       "==%i" % req.user.userID], 
                                 single=True)

        if tagUser == () or not tagUser.canWrite:
            raise OpenomyError(ERR_UNAUTHORIZED)
    
    # Make sure the file actually belongs to the tag
    fileTag = FileTag.select(req.db, 
                             vals=["==%i" % fileID, 
                                   "==%i" % tagID], 
                             single=True)
    if fileTag == ():
        raise OpenomyError(ERR_BAD_FILETAG)
    
    # Finally remove the tag    
    fileTag.delete(req.db)
    return "File removed from tag."

DeleteFileFromTag = exposedmethod(DeleteFileFromTag)
DeleteFileFromTag.params = { "tagID": int, "fileID": int }
DeleteFileFromTag.exposed = True





</t>
<t tx="ahab.20060520014436">

def GetAllTags(req):
    titplt = Tags.CreateTag.template
    
    # Collect all the tag names
    tagItems = []
    for tagUser in TagUser.select(req.db, fields=['userID'],
        vals=["==%i" % req.user.userID]):
        tag = Tag.select(req.db, vals=["==%i" % tagUser.tagID], single=True)
        if tag != ():
            tagItems.append( titplt % tag.__dict__ )
    
    allTags = { "tagItems": ''.join(tagItems) }
    return req.template % allTags

GetAllTags = exposedmethod(GetAllTags)
GetAllTags.exposed = True
GetAllTags.template = "  &lt;tags&gt;\n%(tagItems)s  &lt;/tags&gt;\n"


</t>
<t tx="ahab.20060520015210">



def GetFile(req, fileID=None, timeout=1):
    # Check the file permissions
    fileUser = FileUser.select(req.db, 
                               fields=['fileID', 'userID'], 
                               vals=["==%i" % fileID, 
                                     "==%i" % req.user.userID], 
                               single=True) 
    if fileUser == ():
        # Check the tag permissions
        authorized = False
        for fileTag in FileTag.select(req.db, 
                                      fields=['fileID'], 
                                      vals=["==%i" % fileID]):
                                          
            tagUser = TagUser.select(req.db, 
                                     vals=["==%i" % fileTag.tagID, 
                                           "==%i" % req.user.userID], 
                                     single=True)
                                     
            if () != tagUser and tagUser.canRead:
                authorized = True
                break
        
        if authorized:
            # Don't calculate the authorization again.
            # Plus, we're checking out the file.
            fileUser = FileUser.newInstance(fileID=fileID,
                         userID=req.user.userID, 
                         canRead=tagUser.canRead,
                         canWrite=tagUser.canWrite, 
                         fullControl=0)
            fileUser.insert(req.db)
            
    elif fileUser.canRead:
        authorized = True
    else:
        authorized = False

    # Make sure we passed the permissions check        
    if not authorized:
        raise OpenomyError(ERR_UNAUTHORIZED)

    # Checkout a new fileToken
    expiry = datetime.datetime.today() + datetime.timedelta(0, timeout * 60)
    fileUser.checkout(expiry)
    fileUser.update(req.db)

    # Retrieve the file object
    file = File.select(req.db, 
                       vals=["==%i" % int(fileID)], 
                       single=True)
    if file == ():
        raise "Server failure."
        
    owner = User.select(req.db, 
                        vals=["==%i" % file.ownerID], 
                        single=True)
    if owner == ():
        owner = req.user
        
    if fileUser.userID == 0 and fileUser.canRead:
        isPublic = True
    else:
        isPublic = False

    dateTimeFormat = "%m/%d/%Y %H:%M:%S %p"
    fileInfo = { 
        "fileID": file.fileID,
        "fileName": file.fileName,
        "created": file.created.strftime(dateTimeFormat),
        "modified": file.modified.strftime(dateTimeFormat),
        "contentType": file.contentType,
        "size": file.size,
        "owner": owner.userName,
        "baseurl": "%s/api/download/" % req.environ['openomy.servicepath'],
        "filetoken": fileUser.fileToken,
        "ispublic": isPublic
        }
    
    return req.template % fileInfo
    

GetFile = exposedmethod(GetFile)
GetFile.params = { "fileID": int, ("timeout",): int }
GetFile.exposed = True
GetFile.template = """  &lt;file id="%(fileID)i"&gt;
    &lt;filename&gt;%(fileName)s&lt;/filename&gt;
    &lt;created&gt;%(created)s&lt;/created&gt;
    &lt;modified&gt;%(modified)s&lt;/modified&gt;
    &lt;contenttype&gt;%(contentType)s&lt;/contenttype&gt;
    &lt;size units="bytes"&gt;%(size)i&lt;/size&gt;
    &lt;owner&gt;%(owner)s&lt;/owner&gt;
    &lt;downloadlink&gt;
      &lt;baseurl&gt;%(baseurl)s&lt;/baseurl&gt;
      &lt;filetoken&gt;%(filetoken)s&lt;/filetoken&gt;
    &lt;/downloadlink&gt;
    &lt;public ispublic="%(ispublic)i" /&gt;
  &lt;/file&gt;
"""


</t>
<t tx="ahab.20060520015210.1">


def AddFile(req, fileField=None, tagID=None):
    
    # Check the user quota
    fileSize = fileField.fp.length
    if req.user.maxQuota &lt;= req.user.curStorage:
        raise OpenomyError(ERR_MAX_QUOTA)
        
    if (req.user.overQuota + req.user.maxQuota &lt;
        req.user.curStorage + fileSize):
        raise OpenomyError(ERR_OVER_QUOTA)
        
    if tagID and () == Tag.select(req.db, vals=["==%i" % tagID], single=True):
        raise OpenomyError(ERR_BAD_TAG)

    # Adjust the user storage consumption
    req.user.curStorage += fileSize
    req.user.setModified()
    req.user.update(req.db) 
        
    file = File.newInstance(fileName=fileField.filename,
        contentType=fileField.type, size=fileSize,
        ownerID=req.user.userID)
    file.insert(req.db)
    
    # Always generate one for the owner.  Saves time later.
    fileUser = FileUser.newInstance(fileID=file.fileID,
        userID=req.user.userID, fullControl=1, canRead=1,
        canWrite=1)
    fileUser.insert(req.db)
    
    # Store the file contents on disk.
    storedFile = StoredFile.instance(file)
    fileData = fileField.file.read()
    storedFile.setData(fileData)
    
    if tagID:
        fileTag = FileTag.newInstance(fileID=file.fileID, tagID=tagID)
        fileTag.insert(req.db)
    
    return "File uploaded."

    #return req.template % file.__dict__

AddFile = exposedmethod(AddFile)
AddFile.params = { "fileField": None, ("tagID",): int }
AddFile.exposed = True
AddFile.template = '  &lt;file id="%(fileID)i"&gt;%(fileName)s&lt;/file&gt;\n'




</t>
<t tx="ahab.20060520015210.2">


def DeleteFile(req, fileID=None):
    # Get the file object
    file = File.select(req.db, 
                       fields=['fileID', 'ownerID'], 
                       vals=["==%i" % fileID, 
                             "==%i" % req.user.userID], 
                       single=True)
    if file == ():
        raise OpenomyError(ERR_UNAUTHORIZED)
        
    # Adjust the user storage consumption
    req.user.curStorage -= file.size
    req.user.setModified()
    req.user.update(req.db)

    # Delete the on-disk file
    storedFile = StoredFile.instance(file)
    storedFile.delete()
    
    # Delete the file record 
    file.delete(req.db)

    # Cascade deletion to link tables
    # Delete all the file permissions
    req.db.delete(FileUser.getTableName(), ['fileID'], ["==%i" % fileID])
    
    # Delete all the file tags
    req.db.delete(FileTag.getTableName(), ['fileID'], ["==%i" % fileID])
    
    return "File deleted."
    
DeleteFile = exposedmethod(DeleteFile)
DeleteFile.params = { "fileID": int }
DeleteFile.exposed = True



</t>
<t tx="ahab.20060520015231">



def ModifyFile(req, fileID=None, fileField=None):
    # Get the user's permissions for the file
    fileUser = FileUser.select(req.db, 
                               fields=['fileID', 'userID'], 
                               vals=["==%i" % fileID, 
                                     "==%i" % req.user.userID], 
                               single=True)    

    if fileUser == ():
        # Check tag permissions
        authorized = False
        for fileTag in FileTag.select(req.db, 
                                      fields=['fileID'], 
                                      vals=["==%i" % fileID]):
                                          
            tagUser = TagUser.select(req.db, 
                                     vals=["==%i" % fileTag.tagID, 
                                           "==%i" % req.user.userID], 
                                     single=True)
            if () != tagUser and tagUser.canWrite:
                authorized = True
                break
    elif fileUser.canWrite:
        authorized = True
    else:
        authorized = False
    
    
    if not fileUser.canWrite:
        raise OpenomyError(ERR_UNAUTHORIZED)

    file = File.select(req.db, vals=["==%i" % fileID], single=True)
    if file == ():
        raise OpenomyError(ERR_UNAUTHORIZED)

    # Update the file record        
    file.size = fileField.fp.length
    file.contentType = fileField.type
    file.fileName = fileField.filename
    file.setModified()
    file.update(req.db)
        
    # Store the file contents on disk.
    storedFile = StoredFile.instance(file)
    storedFile.setData(fileField.file.read())
        
    return "File modified."   
    
ModifyFile = exposedmethod(ModifyFile)
ModifyFile.params = { "fileID": int, "fileField": None }
ModifyFile.exposed = True






</t>
<t tx="ahab.20060520015252">


def GetAllFiles(req):    
    # Direct user ownership
    fileUsers = FileUser.select(req.db,
                            fields=['userID'], 
                            vals=["==%i" % req.user.userID])
        
    # Convert TagUser and FileUser to File
    files = dict()
    for fileUser in fileUsers:
        file = File.select(req.db, 
                           vals=["==%i" % fileUser.fileID], 
                           single=True)
        if file != ():
            files[file.fileID] = file
        
    # Tag-user files
    for tagUser in TagUser.select(req.db,
                          fields=['userID', 'canRead'],
                          vals=['==%i' % req.user.userID, "==1"]):
        for fileTag in FileTag.select(req.db,
                                      fields=['tagID'],
                                      vals=['==%i' % tagUser.tagID]):
            if fileTag.fileID in files: continue
            file = File.select(req.db,
                               fields=['fileID'],
                               vals=['==%i' % fileTag.fileID])
            if file != ():
                files[file.fileID] = file
    
    # Sort the list by fileID
    fileKeys = files.keys()
    fileKeys.sort()

    # Convert to XML
    fitplt = Files.AddFile.template
    fileItems = [ fitplt % files[key].__dict__ for key in fileKeys]
    return req.template % { "fileItems": ''.join(fileItems) }

GetAllFiles = exposedmethod(GetAllFiles)
GetAllFiles.exposed = True
GetAllFiles.template = " &lt;files&gt;\n%(fileItems)s &lt;/files&gt;\n"




</t>
<t tx="ahab.20060520230315"># ///////////////////////////////////
# Retrieves an entire wiki page.
from leoWiki import *

wikipos, wikiname, wikibase = wiki(p)
#wikisect = wikiSect(wikipos, p)
#if wikisect == 0: wikisect = None

g.es("Wiki Base: %s" % wikibase, color="blue")
g.es("  retrieving %s..." % wikiname, color="purple")

try:
    wikibody = wikiLoad(wikibase, wikiname)
    wikipos.setBodyString(wikibody)
except:
    g.es_exception()

g.es("Finished.", color="blue")</t>
<t tx="ahab.20060520234228">==Overview==
The goal of the Openomy APIs is to be as easy to use as possible. However, because Openomy deals directly with user data (which could be sensitive data), it is also imperative that both the user and developer feel in control at all times. I think I have found a solution which achieves both of these goals. If you have any suggestions to improve this process, [mailto:iseff@iseff.com let me know].


==Creating an application==
To create an application, visit http://www.openomy.com/api/createapplication/. Once you've filled out this form, you'll be given an [[Application_Key|application key]] and a [[Private_Key|private key]]. You will need both of these keys to use your application.


==The keys==
The [[Application_Key|application key]] is a public key which you will use to let Openomy and your users know who you are. For example, in order to access a user's data, the user must first authorize your application to do so. How do they do that? Well, you send them to: http://www.openomy.com/api/login/?applicationKey={yourapplicationkey}. At that page the user will see the name and description of your application as well as a submit button to authorize your application. Upon authorization, the user will be redirected to the URL you provided. Appended to that URL will be an [[Unconfirmed_Token|unconfirmed token]] (more about that below).

The [[Private_Key|private key]] is a PRIVATE key ('''i.e. do not share this key with anyone''') which helps to confirm that each API call you make is, in fact, made by you and not someone posing as you. To do this, most (currently: all) API calls need to be signed (more on this later).


==The tokens==
In order to successfully authorize an application to access a user's data, both the user '''and the''' application have to acknowledge this authorization. This begins with the user authorizing the application access through the form at http://www.openomy.com/api/login/?applicationKey={yourapplicationkey} (see above). The user is then redirected to the page you requested with an additional variable appended to the query string. This is the [[Unconfirmed_Token|unconfirmed token]]. The unconfirmed token says that one-half of the authorization is complete and now the other half must also authorize. 

Your application will now have to do its part to get the [[Confirmed_Token|confirmed token]]. The confirmed token associates users and applications so that only the authorized application can access the user's data (and vice versa). To retrieve the confirmed token, call the [[Auth.GetConfirmedToken]] method, supplying the unconfirmed token as an argument.


==Making calls==
In order to make the Auth.GetConfirmedToken call, you need to know how to make calls in the first place. The Openomy API is a [http://en.wikipedia.org/wiki/REST REST-based] API, which means it uses very simple HTTP requests to make calls. For most requests (all except for uploading a file), this means you simply have to construct a query string and make a GET request. 

===Constructing the query string===
Constructing the query string is really very easy. It always requires two variables, usually a third (but not always) and the rest are dependent upon the method you are calling.
# Begin with the root URL: http://www.openomy.com/api/rest/
# Add the first required variable, method. This is the method you are calling (e.g. Auth.GetConfirmedToken). http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken
# Add the second required variable. If you are calling Auth.GetConfirmedToken, then this is unconfirmedToken. Otherwise, this will be the confirmedToken. http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}
# Add the third required variable. This is the applicationKey.
http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}&amp;applicationKey={yourapplicationkey}
# Add any other variables you need to for the method call. In the case of Auth.GetConfirmedToken, we are finished.
# If necessary, which it almost always is, add the third required variable: signature.
## Create your unhashed signature for this call by ordering the variables in alphabetical order and appending your private key to this new string. Example: applicationKey={yourapplicationkey}method=Auth.GetConfirmedTokenunconfirmedToken={someunconfirmedtoken}{yourprivatekey}.
## Calculate the MD5 hash of this string to create the signature. 
# The completed URL will be http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}&amp;applicationKey={yourapplicationkey}&amp;signature={MD5hashofsignature}.

===Making the call===
Now that you know what URL you're going to call, you simply open an HTTP connection to this URL and receive the result. This should be extremely easy in virtually all programming languages.


==Receiving results==
The result which is returned by the API call is an XML document. Though every call is different and therefore every response is different, there is a standard structure to these results. You will either be returned a success or an error.

===Success===
If the call is successful, you will receive a success response. The general format of a success is:
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  ... some result here ...
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
The body in between the success tags will vary greatly depending on the call made. Check the documentation on the specific call for more information.

===Failure===
If the call is not successful, you will receive an error response. The general format of an error is:
&lt;blockquote&gt;&lt;pre&gt;
&lt;error code="... some integer ..."&gt;
  ... some error description ...
&lt;error&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
Error codes will be documented [[Error_Codes|here]].


==Using these results==
How you use these results is up to you, but my personal opinion is that you should use whatever XML functionality is built into the programming language you are using to obtain the values of each result.


==Example==
There have been a few questions about the above authentication system, so we decided that we should add a little example story for illustrative purposes.

There are two characters: 
# Doug, the developer for dougrocks.com, an site that lets users compose music on a cool AJAX based keyboard and save them in MIDI format.
# Eve, an end user who has been playing the piano since she was 10.

====Step 1: Create the Application====

Doug wants to integrate his web application with Openomy so users can have easy access to their saved files-- so he logs into Openomy and goes to the "create application" link on the toolbar. Doug enters some basic information about his application and a callback URL for his website (let's say it's http://dougrocks.com/callback --more on this later). He submits the form and gets an application key and private key pair from Openomy. These two pieces uniquely identify his application-- think of it as a username and password.

Doug builds his web application and saves this pair in the app. He then blogs about it and the Web 2.0 community goes wild. 

====Step 2: Granting Access to Files====

Eve sees this blog entry on Doug's RSS feed. She decides that she wants to checkout dougrocks.com, which uses Eve's Openomy account to save any songs she creates. When she is registering on Doug's site, dougrocks.com redirects her to:

http://www.openomy.com/api/login/?applicationKey={doug's appkey}&amp;userid={Eve's userid on dougrocks.com}&amp;signature={this call's encrypted signature, as described above}

Openomy asks Eve to login and then asks her if she wants to give dougrocks.com access to her files. She says yes.

====Step 3: The Callback====

Now Openomy forwards her to: http://dougrocks.com/callback?unconfirmedtoken={Eve's unconfirmedtoken}&amp;userid={Eve's userid},

This is the callback that Doug entered when he registered his application with Openomy. Notice that the userid is passed back, so dougrocks.com can keep track of which tokens correspond to which users. In general, all fields passed to the login script on Openomy are returned to the callback, except for the applicationKey and signature fields.

To make sure everything is kosher, dougrocks.com makes the Auth.GetConfirmedToken({Eve's unconfirmedtoken}) API call, and gets back Eve's confirmedToken. This last token is what lets dougrocks.com access Eve's Openomy account, as long as it is authorized to do so by Eve. Presently, they dont expire.. so they can just be stored in the DB along with your user's profile. The confirmedToken is a required argument on all API calls that access a users account.

Now dougrocks.com can save all of Eve's files on openomy and Eve can then share them with her friends.
</t>
<t tx="ahab.20060520234228.1">This is a comprehensive list of all methods which are currently supported. More will be continuously added, so be sure to check back often. If you have a request for a specific method, [mailto:iseff@iseff.com contact me].


==Authentication==
The authentication methods help to make sure that only the right users and applications can talk to each other.
* [[Auth.GetConfirmedToken]]
* [[Auth.GetUnconfirmedToken]]
* [[Auth.AuthorizeUser]]
* [[Auth.RegisterUser]]


==Tags==
The tag methods perform actions on tags. 
* [[Tags.GetAllTags]]
* [[Tags.GetTag]]
* [[Tags.CreateTag]]
* [[Tags.DeleteTag]]
* [[Tags.AddFileToTag]]
* [[Tags.DeleteFileFromTag]]


==Files==
The file methods perform action on files.
* [[Files.GetFile]]
* [[Files.AddFile]]
* [[Files.DeleteFile]]
* [[Files.ModifyFile]]
* [[Files.GetAllFiles]]
</t>
<t tx="ahab.20060520234449">==Description==
This call creates a [[Confirmed_Token| confirmed token]] and therefore associates applications to users. This completes the authorization process.

This method is signed.


==Arguments==
* '''username''': The Openomy username of the user who wants to authorize your application.
* '''password''': The Openomy password of the user who wants to authorize your application.


==Returns==
The confirmed token associating the application to the user. 


==Sample response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;confirmedtoken&gt;1234567890abcdefghijkl0123&lt;confirmedtoken&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060520234510">==Description==
This call first registers a new user with Openomy and then creates a [[Confirmed_Token| confirmed token]] and therefore associates applications to users. This completes the authorization process.

This method is signed.


==Arguments==
* '''username''': The requested username to login to Openomy with.
* '''password''': The requested password to be associated with the username.
* '''email''': The email address to associate with the user.


==Returns==
The confirmed token associating the application to the user. 


==Sample response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;confirmedtoken&gt;1234567890abcdefghijkl0123&lt;confirmedtoken&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060520234510.1">==Description==
This call creates an [[Unconfirmed_Token| unconfirmed token]] and therefore begins to associate applications to users. This begins the authorization process and is only needed by non-web apps. For further explanation, please check out [[How_Non-Web_Apps_Work | How Non-Web Apps Work]].

This method is signed.


==Arguments==
This method takes no arguments other than the required applicationKey and signature.


==Returns==
The unconfirmed token which begins associating applications to users and starts the authorization process. This unconfirmed token will be passed to the Openomy API authorization page to create a confirmed token. This is explained in [[How_Non-Web_Apps_Work | How Non-Web Apps Work]]. 


==Sample response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;unconfirmedtoken&gt;1234567890abcdefghijkl0123&lt;unconfirmedtoken&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060520234532">==Description==
This call creates a [[Confirmed_Token| confirmed token]] and therefore associates applications to users. This completes the authorization process.

This method is signed.


==Arguments==
* '''unconfirmedToken''': The [[Unconfirmed_Token|unconfirmed token]] created by one of the two parties (user or application).


==Returns==
The confirmed token associating the application to the user. 


==Sample response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;confirmedtoken&gt;1234567890abcdefghijkl0123&lt;confirmedtoken&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521000819">==Description==
Gets information, including the name, the date created, the files within, the id, etc. about the tag in question.

This method is signed.


==Arguments==
* '''tagID''': The id of the tag you are looking to retrieve information about.


==Returns==
'''Attributes''': id, name, created date

'''Nodes''': users who are collaborating on this tag, and files which are tagged with this tag. Information about whether or not the user has admin priveleges on this tag is included in the attributes of the &lt;user&gt; nodes. Information about whether or not the calling calling user has read/write access to the file, the file id, and the created date of the file is included in the attributes of the &lt;file&gt; nodes.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;tag id="1" name="first ever tag" created="09/01/2005 12:00:01 AM"&gt;
    &lt;users&gt;
      &lt;user admin="1"&gt;iseff&lt;/user&gt;
      &lt;user admin="0"&gt;baduser&lt;/user&gt;
    &lt;/users&gt;
    &lt;files&gt;
      &lt;file id="1" created="09/01/2005 12:00:02 AM" readaccess="1" writeaccess="1"&gt;foo.txt&lt;/file&gt;
      &lt;file id="2" created="09/01/2005 12:00:03 AM" readaccess="1" writeaccess="1"&gt;bar.txt&lt;/file&gt;
    &lt;/files&gt;
  &lt;/tag&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521000942">==Description==
Retrieves a list of all the tags for a user. This includes tags the user has created as well as tags the user was invited to (and accepted).

This method is signed.


==Arguments==
No arguments are required other than the method name and confirmed token, as always.


==Returns==
A list of tags and their ids.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;tags&gt;
    &lt;tag id="1"&gt;first tag ever&lt;tag&gt;
    &lt;tag id="2"&gt;second tag ever&lt;/tag&gt;
  &lt;/tags&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521000942.1">==Description==
Creates a new tag associated with a user.

This method is signed.


==Arguments==
* '''tagName''': The name of the tag you are going to create.


==Returns==
'''Attributes''': id

'''Nodes''': tag: Simply the name of the tag you created, with the id (as above) listed as an attribute.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;tag id="1"&gt;
    My new tag
  &lt;/tag&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001003">==Description==
Deletes a tag if the user is an admin or creator of the tag.

This method is signed.


==Arguments==
* '''tagID''': The id of the tag you are going to delete.


==Returns==
Either success or error.

==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  Tag deleted.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001003.1">==Description==
Adds a file to a specific tag.

This method is signed.


==Arguments==
This method takes two arguments: '''fileID''' - the id of the file which you want to add to a tag, and '''tagID''' - the id of the tag to which you want to add the file.


==Returns==
Success or error notification.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
     File added to tag.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001003.2">==Description==
Deletes a file from a specific tag.

This method is signed.


==Arguments==
This method takes two arguments: '''fileID''' - the id of the file which you want to add to a tag, and '''tagID''' - the id of the tag to which you want to add the file.


==Returns==
Success or error notification.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
     File removed from tag.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001106">==Description==
Gets all the information about a file and sets up a link to where the file itself can be downloaded. This happens so that the metadata about the file doesn't get mixed in with the binary data of the file. 


==Arguments==
* '''fileID''': The id of the file you wish to retrieve
* '''timeout''' (optional): The length of time, in ''minutes'' of how long to allow the download link to be active. Default is 1, max is 20.


==Returns==
'''Attributes''': The id of the file

'''Nodes''': The filename, created date, the last-modified date, the content type, the size (with the units of measure as an attribute), the owner, and the download link. The download consists of two nodes, the baseurl and the filetoken. Combining the baseurl with ?fileToken={filetoken}, you get the full URL.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  &lt;file id="1"&gt;
    &lt;filename&gt;foo.txt&lt;/filename&gt;
    &lt;created&gt;09/01/2005 12:00:01 AM&lt;/created&gt;
    &lt;modified&gt;09/01/2005 12:00:01 AM&lt;/modified&gt;
    &lt;contenttype&gt;text/plain&lt;/contenttype&gt;
    &lt;size units="bytes"&gt;11492&lt;/size&gt;
    &lt;owner&gt;iseff&lt;/owner&gt;
    &lt;downloadlink&gt;
      &lt;baseurl&gt;http://www.openomy.com/api/download/&lt;/baseurl&gt;
      &lt;filetoken&gt;1234567890asdfasdf1234&lt;/filetoken&gt;
    &lt;/downloadlink&gt;
  &lt;/file&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001106.1">==Description==
This is one of the few requests which is sent via a POST request rather than a GET request. Moreover, this is sent as a multipart/form-data content type. Your request must conform to [http://www.faqs.org/rfcs/rfc1867.html RFC 1867] (form based HTTP file upload).


==Arguments==
* '''tagID''': (optional) The default tag to which this file will be tagged. If this argument is omitted, or if it is set to 0, then the file will be uploaded with no tags applied.
* '''fileField''': The binary data of the file, along with some metadata (filename, etc). Exactly how RFC 1867 shows.

==Returns==
A success notification.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  File uploaded.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;


==Example code==
The following is an example Perl script which uploads a file.
&lt;blockquote&gt;&lt;pre&gt;
#! /usr/bin/perl

use strict;
use warnings;

use LWP;
use HTTP::Request::Common;
use Digest::MD5 qw(md5_hex);

my $b = LWP::UserAgent-&gt;new;
my $url = "http://www.openomy.com/api/rest/";

my $filename = "/home/iseff/testUpload.txt";
my $applicationKey = "1234567890abcd1234";
my $confirmedToken = "abcdefghijklmnop1234567890";
my $privateKey = "0123456789";
my $method = "Files.AddFile";
my $tagID = "1";
my $unhashed = "applicationKey=$applicationKey"."confirmedToken=$confirmedToken";
$unhashed .= "method=$method"."tagID=$tagID"."$privateKey";
my $signature = hash($unhashed);

my $response = $b-&gt;request(POST "$url",
                           Content_Type =&gt; 'form-data',
                           Content =&gt; [ method =&gt; "$method",
                                        applicationKey =&gt; "$applicationKey",
                                        confirmedToken =&gt; "$confirmedToken",
                                        signature =&gt; "$signature",
                                        tagID =&gt; "$tagID",
                                        fileField =&gt; ["$filename"],
                                        ]
                           );

print $response-&gt;content . "\n";


sub hash
{
    my ($query) = @_;
    return uc(md5_hex($query));
}
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001106.2">==Description==
Deletes the given file from Openomy. 

==Arguments==
* '''fileID''': The id of the file you wish to delete.

==Returns==
Confirmation that the action was successful.

==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  File deleted.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001128">==Description==
Replaces the file with the given id with the newly uploaded file. All tags and permissions are maintained.

This is one of the few requests which is sent via a POST request rather than a GET request. Moreover, this is sent as a multipart/form-data content type. Your request must conform to [http://www.faqs.org/rfcs/rfc1867.html RFC 1867] (form based HTTP file upload).


==Arguments==
* '''fileID''': The default tag to which this file will be tagged.
* '''fileField''': The binary data of the file, along with some metadata (filename, etc). Exactly how RFC 1867 shows.


==Returns==
A success notification.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
  File modified.
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001128.1">==Description==
This method returns information on all of the files on your Openomy account, including the files that have no tags associated with them.

==Arguments==
None.

==Returns==
An XML document that maps filenames to file ids, for all the files on your account.


==Sample Response==
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&gt;
 &lt;files&gt;
  &lt;file id="1"&gt;README.txt&lt;/file&gt;
  &lt;file id="2"&gt;HelloWorld.rb&lt;/file&gt;
  &lt;file id="3"&gt;image1.jpg&lt;/file&gt;
  &lt;file id="4"&gt;image2.jpg&lt;/file&gt;
  &lt;file id="5"&gt;readinglist.opml&lt;/file&gt;
 &lt;/files&gt;
&lt;/success&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
</t>
<t tx="ahab.20060521001251">==Overview==
The goal of the Openomy APIs is to be as easy to use as possible. However, because Openomy deals directly with user data (which could be sensitive data), it is also imperative that both the user and developer feel in control at all times. I think I have found a solution which achieves both of these goals. If you have any suggestions to improve this process, [mailto:iseff@iseff.com let me know].


==Creating an application==
To create an application, visit http://www.openomy.com/api/createapplication/. Once you've filled out this form, you'll be given an [[Application_Key|application key]] and a [[Private_Key|private key]]. You will need both of these keys to use your application.


==The keys==
The [[Application_Key|application key]] is a public key which you will use to let Openomy and your users know who you are. For example, in order to access a user's data, the user must first authorize your application to do so. How do they do that? Well, you send them to: http://www.openomy.com/api/login/?applicationKey={yourapplicationkey}&amp;unconfirmedToken={unconfirmedtoken}&amp;signature={signature}. At that page the user will see the name and description of your application as well as a submit button to authorize your application. 

The [[Private_Key|private key]] is a PRIVATE key ('''i.e. do not share this key with anyone''') which helps to confirm that each API call you make is, in fact, made by you and not someone posing as you. To do this, most (currently: all) API calls need to be signed (more on this later).


==The tokens==
In order to successfully authorize an application to access a user's data, both the user '''and the''' application have to acknowledge this authorization. With non-web apps, this begins with the application calling the [[Auth.GetUnconfirmedToken|Auth.GetUnconfirmedToken]] API call. Making this call will return an unconfirmed token, which is half of the authorization process. 

Now you will have to direct a user to the API authorization page, and include the unconfirmed token you just received: 
http://www.openomy.com/api/login/?applicationKey={yourapplicationkey}&amp;unconfirmedToken={theuncofirmedtoken}&amp;signature={somesignature}
You'll learn about constructing these signatures below.

Once the user has authorized this, they will return to your application (you'll probably want a way to have the user let you know when they're done authorizing).

Your application will now have to do its part to get the [[Confirmed_Token|confirmed token]]. The confirmed token associates users and applications so that only the authorized application can access the user's data (and vice versa). To retrieve the confirmed token, call the [[Auth.GetConfirmedToken]] method, supplying the unconfirmed token as an argument.


==Making calls==
In order to make the Auth.GetConfirmedToken call, you need to know how to make calls in the first place. The Openomy API is a [http://en.wikipedia.org/wiki/REST REST-based] API, which means it uses very simple HTTP requests to make calls. For most requests (all except for uploading a file), this means you simply have to construct a query string and make a GET request. 

===Constructing the query string===
Constructing the query string is really very easy. It always requires two variables, usually a third (but not always) and the rest are dependent upon the method you are calling.
# Begin with the root URL: http://www.openomy.com/api/rest/
# Add the first required variable, method. This is the method you are calling (e.g. Auth.GetConfirmedToken). http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken
# Add the second required variable. If you are calling Auth.GetConfirmedToken, then this is unconfirmedToken. Otherwise, this will be the confirmedToken. http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}
# Add the third required variable. This is the applicationKey.
http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}&amp;applicationKey={yourapplicationkey}
# Add any other variables you need to for the method call. In the case of Auth.GetConfirmedToken, we are finished.
# If necessary, which it almost always is, add the third required variable: signature.
## Create your unhashed signature for this call by ordering the variables in alphabetical order and appending your private key to this new string. Example: applicationKey={yourapplicationkey}method=Auth.GetConfirmedTokenunconfirmedToken={someunconfirmedtoken}{yourprivatekey}.
## Calculate the MD5 hash of this string to create the signature. 
# The completed URL will be http://www.openomy.com/api/rest/?method=Auth.GetConfirmedToken&amp;unconfirmedToken={someunconfirmedtoken}&amp;applicationKey={yourapplicationkey}&amp;signature={MD5hashofsignature}.

===Making the call===
Now that you know what URL you're going to call, you simply open an HTTP connection to this URL and receive the result. This should be extremely easy in virtually all programming languages.


==Receiving results==
The result which is returned by the API call is an XML document. Though every call is different and therefore every response is different, there is a standard structure to these results. You will either be returned a success or an error.

===Success===
If the call is successful, you will receive a success response. The general format of a success is:
&lt;blockquote&gt;&lt;pre&gt;
&lt;success&amp;gt;
  ... some result here ...
&lt;/success&amp;gt;
&lt;/pre&gt;&lt;/blockquote&gt;
The body in between the success tags will vary greatly depending on the call made. Check the documentation on the specific call for more information.

===Failure===
If the call is not successful, you will receive an error response. The general format of an error is:
&lt;blockquote&gt;&lt;pre&gt;
&lt;error code="... some integer ..."&amp;gt;
  ... some error description ...
&lt;error&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
Error codes will be documented [[Error_Codes|here]].


==Using these results==
How you use these results is up to you, but my personal opinion is that you should use whatever XML functionality is built into the programming language you are using to obtain the values of each result.


==Example==
There have been a few questions about the above authentication system, so we decided that we should add a little example story for illustrative purposes.

There are two characters: 
# Doug, the developer for dougrocks, a Java application that lets users compose music on a cool Swing based keyboard and save them in MIDI format.
# Eve, an end user who has been playing the piano since she was 10.

====Step 1: Create the Application====

Doug wants to integrate his non-web application with Openomy so users can have easy access to their saved files-- so he logs into Openomy and goes to the "create application" link on the toolbar. Doug enters some basic information about his application. He submits the form and gets an application key and private key pair from Openomy. These two pieces uniquely identify his application-- think of it as a username and password.

Doug builds his non-web application and saves this pair in the app.

====Step 2: Granting Access to Files====

Eve sees this blog entry on Doug's RSS feed. She decides that she wants to checkout dougrocks, which uses Eve's Openomy account to save any songs she creates. When she is installing dougrocks it redirects her to:

http://www.openomy.com/api/login/?applicationKey={doug's appkey}&amp;signature={this call's encrypted signature, as described above}

Openomy asks Eve to login and then asks her if she wants to give dougrocks access to her files. She says yes.

====Step 3: The Confirmed Token====

Now Openomy tells Eve to close her browser and return to dougrocks. Dougrocks is waiting for her to click "I've finished authorizing."

Now, to make sure everything is kosher, dougrocks makes the Auth.GetConfirmedToken({Eve's unconfirmedtoken}) API call, and gets back Eve's confirmedToken. This last token is what lets dougrocks access Eve's Openomy account, as long as it is authorized to do so by Eve. Presently, they dont expire.. so they can just be stored in the DB along with your user's profile. The confirmedToken is a required argument on all API calls that access a users account.

Now dougrocks can save all of Eve's files on openomy and Eve can then share them with her friends.
</t>
<t tx="ahab.20060521001312">The following is a table of error codes to their meanings. 

{| width="95%"
| '''Code''' || '''Meaning''' || '''Description'''
|-
| 0 || Invalid token || The token (either unconfirmed or confirmed) was not valid.
|-
| 1 || Invalid signature || The MD5 based signature did not match what Openomy produced.
|-
| 2 || Permissions || The application does not have enough permissions to perform the requested call.
|-
| 3 || Null Reference || One or more of the arguments was null. You're probably missing an argument (maybe a token or key?).
|-
| 4 || General || A general, undescribed, error occured.
|-
| 5 || Tag Name Not Valid || The name of the tag you are describing is not valid. Perhaps forbidden characters or already used?
|-
| 6 || User Not Found || The user you are requesting was not found.
|-
| 7 || File Too Large || The file you are trying to upload was too large based on the user's quota.
|-
| 8 || Out Of Storage || The user is out of storage space and the requested call could not be completed.
|-
| 9 || InvalidApplicationKey || The applicationKey you passed was invalid.
|-
| 10 || UnknownMethod || The method you passed was unknown (or you didn't pass a method).
|}
</t>
<t tx="ahab.20060521001353"></t>
<t tx="ahab.20060521001353.1">The confirmed token (represented as: confirmedToken) is created when both parties (the user and the application) have authorized use of the user's data by the application. It uniquely associates applications to users. 

Confirmed tokens will soon have the ability of being time limited, but currently they last until the user removes the authorization from their account at http://www.openomy.com/api/list/.


==Creating confirmed tokens==
For web apps, confirmed tokens are created by calling the [[Auth.GetConfirmedToken]] API call with the [[Unconfirmed_Token|unconfirmedToken]] as an argument.
</t>
<t tx="ahab.20060521001414">To complete an authorization of a user's data to an application, both sides must participate in this authorization. When  the first side has participated, the unconfirmed token (represented as: unconfirmedToken) is created. This is then used by the other side to create the [[Confirmed_Token|confirmed token]] which fully associates users and applications and allows data-sensitive API calls to be made.
</t>
<t tx="ahab.20060521001414.1">The private key is a key given to you by Openomy when you create your application, along with your public [[Application_Key|application key]]. You should never share this key with anyone, as it helps to ensure the authenticity of an API call through the use of signatures.


==The private key and signatures==
When all data-sensitive calls are made, they need to be signed. Signing occurs by doing:
#  Create your unhashed signature for this call by ordering the variables in alphabetical order and appending your private key to this new string. Example: method=Auth.GetConfirmedTokenunconfirmedToken={someunconfirmedtoken}{yourprivatekey}.
# Calculate the MD5 hash of this string to create the signature.

You then attach this signature to your call as signature={md5signature}. Openomy will then match this signature to make sure the call was actually sent by you and not someone posing as you.
</t>
<t tx="ahab.20060521001435">The application key is a public key which is used to identify an application uniquely. You will need this application key to send users to the correct URL for them to authorize your application. To do so, send them to http://www.openomy.com/api/login/?applicationKey={yourapplicationkey}.
</t>
<t tx="ahab.20060521001517">==Welcome==
This is the Openomy documentation. It serves as a reference for the Openomy APIs. It is a wiki, but it is not globally editable. If you think you'd be of help with this documentation, [mailto:iseff@iseff.com email me]. Along with the main [http://www.openomy.com Openomy.com] site, I'll be working on the design of this site soon. For now, though, I'm concentrating on the actual documentation.


==What are APIs?==
APIs are application programming interfaces. They are the core of Openomy, allowing outside developers to create interesting and unique applications which store and retrieve data for users on/from the Openomy servers.


==Why APIs?==
I've written fairly extensively in [http://www.iseff.com my blog] about why APIs are such a great thing, especially in the post I wrote [http://www.iseff.com/2005/07/introducing-openomy.html introducing Openomy]. That's a worthwhile read, in my opinion, to anyone new to Openomy. 


The APIs in Openomy allow anyone and everyone to create extremely useful, valuable, and interesting applications quickly and easily. As more and more of a person's data and work goes online, there are more and more reasons to have a central place for that work. Openomy is striving to be that place. And in order to be the most useful it can be, I have created the APIs for people to access their data and work in new and innovative ways.

 
==Getting Started==
If you're just getting started writing an application which uses the Openomy APIs, I suggest you begin by reading [[How_Web_Apps_Work|how web apps work]] if you're creating a web application or [[How_Non-Web_Apps_Work|how non-web apps work]] if you're creating a non-web application.


==Methods==
Take a look at the list of [[Currently_Supported_Methods|currently supported methods]], organized by type, to see what you can do with your application.


==API Language Bindings==
Here is a list of bindings of the Openomy API for various languages:

# [[Openomy_Ruby | Ruby - openomy-ruby 0.3]]
# [http://openomy.sourceforge.net Python]
# [http://www.shex.co.uk/other/openomy/ PHP]
</t>
<t tx="ahab.20060521014212">This page outlines a number of projects developed by Openomy community members.</t>
<t tx="ahab.20060521014254"></t>
<t tx="ahab.20060521014254.1"></t>
<t tx="ahab.20060521175746"></t>
<t tx="ahab.20060522200347">


class Download:
              
    @others
    
    
</t>
<t tx="ahab.20060522201349">

# KirbyDB table/object abstraction

class KirbyObject:
    VALTYPES = { 
        "str": "String", 
        "float": "Float",
        "bool": "Boolean", 
        "int": "Integer",
        "datetime": "DateTime",
        "date": "Date" 
        }
    
    PATH = "~/.openomy/server/tables/"
    PATH = os.path.expanduser(PATH)
        
    # Basic properties    
    created = datetime.datetime.today()
    modified = datetime.datetime.today()

    def getTableName(cls):
        if not os.path.exists(cls.PATH):
            os.makedirs(cls.PATH)
        return os.path.join(cls.PATH, cls.__name__)
    getTableName = classmethod(getTableName)

    def tabledef(klass, parent=None):
        # Search the parent klass
        if parent:
            ptabledef = parent.tabledef
        else:
            ptabledef = ()
        
        if callable(ptabledef): 
            ptabledef = ptabledef(parent)
            
        attrs = list(ptabledef)
        for attr, val in klass.__dict__.items():
            if attr[:1] == "_": continue  # Skip volatile attributes
            valtype = type(val).__name__
            valtype = KirbyObject.VALTYPES.get(valtype, None)
            if valtype:
                attrs.append(":".join((attr,valtype)))
        attrs.sort()
        return tuple(attrs)
    tabledef = staticmethod(tabledef)
    
    def select(cls, db, fields=None, vals=None, single=False):
        table = cls.getTableName()
        if not getattr(cls, 'exists', False): cls.ensureTableExists(db)
        if not fields: fields = cls.keys
        if not vals: 
            raise ValueError, "No vals specified for select."
        result = db.select(table, fields, vals, returnType='dict')
        ret = list()
        for record in result:
            instance = cls.instance(**record)
            instance._db = db
            if single: return instance
            ret.append(instance)
        return tuple(ret)
    select = classmethod(select)

    def instance(cls, **data):
        obj = cls()
        obj.__dict__.update(data)
        return obj
    instance = classmethod(instance)    

    def newInstance(cls, **kwargs):
        obj = cls.instance(**kwargs)
        obj.setCreated()
        obj.setModified()
        return obj
    newInstance = classmethod(newInstance)
    
    def getNewKey(cls, db):
        obid = ObjectID.select(db, vals=[cls.__name__], single=True)
        if obid == tuple():
            obid = ObjectID.instance()
            obid.table = cls.__name__
            newRec = True
        else:
            newRec = False
        obid.cur += 1
        obid.setModified()
        if not newRec:
            obid.update(db)
        else:
            obid.insert(db)
        return obid.cur
    getNewKey = classmethod(getNewKey)
    
    def setCreated(self):
        self.created = datetime.datetime.today()
        
    def setModified(self):
        self.modified = datetime.datetime.today()
        
    def getKeys(self, fields=None):
        if not fields and hasattr(self, 'recno'):
            keys, keyvals = ['recno'], [self.recno]
        else:
            keys = fields or self.keys
            keyvals = [ getattr(self, key) for key in keys ]
        return keys, keyvals
    
    def insert(self, db):
        self._db = db or self._db
        if not getattr(self, 'exists', False): self.ensureTableExists(self._db)
        for key in self.keys:
            if not getattr(self, key, None):
                setattr(self, key, self.getNewKey(self._db))
        self.recno = db.insert(self.getTableName(), self)
        args = (self.getTableName(),) + self.getKeys()
        recvals = self._db.select(returnType='dict', *args)[0]
        self.__dict__.update(recvals)
        return self.recno
        
    def delete(self, db=None):
        self._db = db or self._db
        if not getattr(self, 'exists', False): self.ensureTableExists(self._db)
        args = (self.getTableName(),) + self.getKeys()
        return (1 == self._db.delete(*args))            
        
    def update(self, db=None):
        self._db = db or self._db
        if not getattr(self, 'exists', False): self.ensureTableExists(self._db)
        args = (self.getTableName(),) + self.getKeys() + (self, )
        return 1 == self._db.update(*args)

    def createTable(cls, db):
        return db.create(cls.getTableName(), list(cls.tabledef))
    createTable = classmethod(createTable)
               
    def dropTable(cls, db):
        if os.path.exists(cls.getTableName()):
            return db.drop(cls.getTableName())
        return True
    dropTable = classmethod(dropTable)
        
    def initTable(cls, db):
        rows = []
        if hasattr(cls, 'initRecs'):
            for row in cls.initRecs:
                rowDict = map(cls.tabledef, row)
                rows.append(cls.newInstance(db=db, **rowDict))
        return rows
    initTable = classmethod(initTable)
    
    def ensureTableExists(cls, db):
        if not os.path.exists(cls.getTableName()):
            cls.createTable(db)
        cls.exists = True
    ensureTableExists = classmethod(ensureTableExists)





</t>
<t tx="ahab.20060523160943">



class StoredFile:

    PATH = "~/.openomy/server/files/"
    PATH = os.path.expanduser(PATH)
    
    fileID = 0
    name = ""
        
    def getFullPath(self):
        return os.path.join(self.PATH, self.name)
        
    def getData(self):
        return file(self.getFullPath(), "r").read()
        
    def setData(self, data):
        if not os.path.exists(self.PATH):
            os.makedirs(self.PATH)
        storedFile = file(self.getFullPath(), "w")
        bytes = storedFile.write(data)
        storedFile.close()
        return bytes
        
    def instance(cls, file):
        storedFileName = "o%05i.f%05i.data" % (file.ownerID, file.fileID)
        obj = cls()
        obj.name = storedFileName
        obj.fileID = file.fileID
        obj.file = file
        return obj
    instance = classmethod(instance)
    
    def delete(self):
        return os.unlink(self.getFullPath())
        





</t>
<t tx="ahab.20060523164646">
class SimpleObject:
    def __init__(self, **attrs):
        for (attr, val) in attrs.items():
            setattr(self, attr, val)

def __init__(self, **objects):
    self._root = REST.SimpleObject(**objects)
    
    # Collect the method info
    tocollect = ('params', 'template', 'tokens')        
    collected = dict()
    self._methods = dict()
    for klassName, klass in objects.items():
        klassCollected = dict(collected)
        klassCollected.update(dict( [ (key, getattr(klass, key))
              for key in tocollect if hasattr(klass, key) ] ))
        
        for methName, method in klass.__dict__.items():
            if callable(method) and getattr(method, 'exposed', False):
                methCollected = dict(klassCollected)
                methCollected.update(dict( [ (key, getattr(method, key))
                      for key in tocollect if hasattr(method, key) ] ))
                methCollected['method'] = method
                fullName = "%s.%s" % (klassName, methName)
                self._methods[fullName] = methCollected
        </t>
<t tx="ahab.20060523171425">


# Call token requirements


TKN_NONE = 0
TKN_CFM = 1
TKN_APP = 2
TKN_SIG = 4

TKN_STD = TKN_CFM  | TKN_APP | TKN_SIG
TKN_AUTH = TKN_APP | TKN_SIG



</t>
<t tx="ahab.20060523172219"></t>
<t tx="ahab.20060523172835">


MODE_TEST = "testing"
MODE_PRODUCTION = "production"

class Service:
    """ Works as either a self-contained WSGI server
        or a WSGI application. """
        
    @others
        
    def serve(self, host='', port=80):
        print "Starting Openomy API server..."
        from paste import httpserver
        httpserver.serve(self.wsgi_app, host=host, port=port)
    
    
</t>
<t tx="ahab.20060523193805"></t>
<t tx="ahab.20060523201221">

    
def _failure(self, req):
    """ Wrap the body in a failure tag. """
    message = req.environ['wsgi.response'].failure.message
    if not message.endswith("\n"): message += "\n"
    if not message.startswith(" "):
        message = "  " + message
    body = "&lt;error&gt;\n%s&lt;/error&gt;" % message
    req.environ['wsgi.response'].content = ['&lt;?xml version="1.0" encoding="UTF-8"?&gt;\n', body]



</t>
<t tx="ahab.20060524154927"></t>
<t tx="ahab.20060524160713">



class ObjectID(KirbyObject):
    """ Similar to SQL-extension "SERIAL" (PG) or 
    "AUTO_INCREMENT" (My). """
    # Keys
    table = ""

    # Props
    min = 1
    step = 1
    max = 32768
    cur = 0

    
ObjectID.tabledef = KirbyObject.tabledef(ObjectID, KirbyObject)
ObjectID.keys = ['table']



</t>
<t tx="ahab.20060524160734">



class Application(KirbyObject):
    """ A client of the Openomy API. """
    
    # Keys
    appID = 0
    
    # Props
    name = ""
    version = ""
    description = ""
    
    applicationKey = ""
    privateKey = ""
    
    # One-to-many links    
    ownerID = 0
    
    def generateKeys(self):
        self.privateKey = str(random.randint(10000000, 99999999))
        message = "".join((self.name, self.version, self.description, str(self.created), str(self.ownerID), self.privateKey))
        self.applicationKey = md5.new(message).hexdigest()
        self.setModified()


Application.tabledef = KirbyObject.tabledef(Application, KirbyObject)
Application.keys = ['appID']




</t>
<t tx="ahab.20060524160734.1">



class ApplicationUser(KirbyObject):
    """ Service contract between app and user """
    
    # Keys (one-to-many links)
    appID = 0
    userID = 0
    # Properties
    unconfirmedToken = ""
    confirmedToken = ""
    
    def __init__(self, app=None):
        if app:
            self.appID = app.appID
    
    def getNewKey(self):
        message = "%10i,%20s,%20s" % (self.appID, str(self.created), str(self.modified))
        return md5.new(message).hexdigest()
        
    def getNewSessionKey(self):
        message = "%10i,%10i,%20s,%20s" % (self.appID, self.userID, str(self.created), str(self.modified))
        digest = sha.new(message).hexdigest()
        # print "Digest: %s" % digest
        return digest
            
    def createOffer(self):
        self.setModified()
        self.unconfirmedToken = self.getNewKey()
    
    def acceptOffer(self, user):
        self.userID = user.userID
        self.setModified()
        self.confirmedToken = self.getNewSessionKey()

    def cancelOffer(self):
        self.confirmedToken = None
        self.setModified()
        
    
ApplicationUser.tabledef = KirbyObject.tabledef(ApplicationUser, KirbyObject)
ApplicationUser.keys = ['unconfirmedToken']




</t>
<t tx="ahab.20060524160734.2">



class User(KirbyObject):
    """ A User with an account. """
    
    # Key
    userID = 0
    # Props
    userName = ""
    password = ""
    email = ""
    
    curStorage = 0
    maxQuota = 1073741824 # 1 GiB
    overQuota = 10485760 # 10MiB
    
User.tabledef = KirbyObject.tabledef(User, KirbyObject)
User.keys = ['userID']




</t>
<t tx="ahab.20060524160755">



class Tag(KirbyObject):
    """ A keyword applied to a group of files. """
    
    # Key
    tagID = 0
    
    # Props
    tagName = ""
    
    # One-To-Many Links
    ownerID = 0
            

Tag.tabledef = KirbyObject.tabledef(Tag, KirbyObject)
Tag.keys = ['tagID']

</t>
<t tx="ahab.20060524160755.1">



class TagUser(KirbyObject):
    """ Access control for a tag """
    # Keys
    tagID = 0
    userID = 0
    
    # Permission props
    canRead = 1
    canWrite = 0
    canReadACL = 0
    canWriteACL = 0

TagUser.tabledef = KirbyObject.tabledef(TagUser, KirbyObject)
TagUser.keys =['tagID', 'userID']




</t>
<t tx="ahab.20060524160816">



class File(KirbyObject):
    """ A unit of storage. """
    
    # Key
    fileID = 0
    
    # Props
    fileName = ""
    size = 0
    contentType = ""
    
    # One-to-many links
    ownerID = 0
    

File.tabledef = KirbyObject.tabledef(File, KirbyObject)
File.keys = ['fileID']





</t>
<t tx="ahab.20060524160816.1">




class FileUser(KirbyObject):
    """ Access control for a file """
    # Keys (one-to-many links)
    fileID = 0
    userID = 0
    
    # Permissions
    canRead = 1
    canWrite = 0
    canReadACL = 0
    canWriteACL = 0
    
    # Token for unauthenticated access
    fileToken = ""
    tokenExpiry = datetime.datetime.today()

    def getNewKey(self, db=None):
        if db: self._db = db
        message = "%10i,%10i,%20s,%20s" % (self.fileID, self.userID, str(self.modified), str(self.tokenExpiry))
        return md5.new(message).hexdigest()
    
    # TODO: Expire these
    def checkout(self, expiry):
        self.tokenExpiry = expiry
        self.setModified()
        self.fileToken = self.getNewKey()
    
    def cancelCheckout(self):
        self.fileToken = ""
        self.setModified()
    
        
FileUser.tabledef = KirbyObject.tabledef(FileUser, KirbyObject)
FileUser.keys = ['fileToken']




</t>
<t tx="ahab.20060524160837">



class FileTag(KirbyObject):
    """ Tagging of a file """
    # Keys (one-to-many links)
    fileID = 0
    tagID = 0
    
    # Properties
    
FileTag.tabledef = KirbyObject.tabledef(FileTag, KirbyObject)
FileTag.keys = ['fileID', 'tagID']





</t>
<t tx="ahab.20060524160919"></t>
<t tx="ahab.20060524160919.1"></t>
<t tx="ahab.20060524160940"></t>
<t tx="ahab.20060524230027">


def CreateApplication(req, name=None, version=None, description=None, ownerID=None):

    app = Application.newInstance(name=name, version=version, description=description, ownerID=ownerID)
    app.generateKeys()
    app.insert(req.db)
    
    return req.template % app.__dict__


CreateApplication = exposedmethod(CreateApplication)
CreateApplication.params = { "name": str, "version": str, "description": str, "ownerID": int }
CreateApplication.template = """  &lt;application id="%(appID)i"&gt;
    &lt;applicationKey&gt;%(applicationKey)s&lt;/applicationKey&gt;
    &lt;privateKey&gt;%(privateKey)s&lt;/privateKey&gt;
  &lt;/application&gt;""" + "\n"


</t>
<t tx="ahab.20070116150015">

_theApp = None
def getApp(mode=MODE_TEST):
    """ Return the global Openomy application service. """
    global _theApp
    if _theApp is None:
        _theApp = Service(mode=mode)
    return _theApp
    

# For mod_python
def app(environ, start_response):
    """ Handle a single response. """
    # Cache the service initialization
    theApp = getApp(MODE_PRODUCTION)
    return theApp(environ, start_response)



# For command line startup
if __name__ == "__main__":
    # Serve until KILL-ed.
    getApp().serve("localhost", 9009)


</t>
</tnodes>
</leo_file>
